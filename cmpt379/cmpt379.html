<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<!-- To display C++ Code -->
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<script type="text/javascript" src="../syntax_highlighter/scripts/shCore.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushCpp.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushBash.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushPlain.js"></script>
		<link type="text/css" rel="stylesheet" href="../syntax_highlighter/styles/shCoreDefault.css"/>
		<script type="text/javascript">SyntaxHighlighter.all();</script>

		<link rel="stylesheet" type="text/css" href="../style.css"/>
		<style type="text/css">
		.arg1{color:red;}
		.arg2{color:green;}
		.arg3{color:blue;}
		.arg4{color:orange;}
		table{max-width: 500px;}
		</style>
		<title>Digital Portfolio of Correy Lim</title>
	</head>
	<body>
	<h3>CMPT 379: Principles In Compiler Design (May 2016 - August 2016)</h3>
	<div class="document">
		<div id="table-of-contents">
			<h2>Table of Contents</h2>
			<body>
			<div class="tableofcontents">
				<table>
					<li><a href="#preface">Preface</a></li>
					<li><a href="#lex">Flex: Lexical Analyzer</a></li>
						<ul>
							<li><a href="#lex_regexp">Regular Expressions</a></li>
							<li><a href="#lex_decaf">Lexical Analyzer for Decaf</a></li>
							<li><a href="#lex_source">Source Code</a></li>
						</ul>
					<li><a href="#parser">YACC/Bison Grammar Parser</a></li>
						<ul>
							<li><a href="#parser_ast">Abstract Syntax Tree</a></li>
							<li><a href="#parser_grammar">Grammar Parser for Decaf</a></li>
							<li><a href="#parser_source">Source Code</a></li>
						</ul>
					<li><a href="#codegen">LLVM Code Generation</a></li>
					<ul>
					</ul>
				</table>
			</div>
			</body>
		</div>
		<h2 id="preface">Preface</h2>
		In this course, my teammate and I were tasked with building a <a href="https://en.wikipedia.org/wiki/Compiler"><b>Compiler</b></a> for a C-like language created for the course, <a href="http://anoopsarkar.github.io/compilers-class/decafspec.html" target="_blank"><b>'Decaf'</b></a>.
		An exercept from the Decaf Specification page:</br></br>
		<div class="commandspec">
			Decaf is a strongly typed C-like language. The feature set is trimmed down considerably from what is usually part of a full-fledged programming language. This is done to keep the programming assignments manageable. Despite these limitations, Decaf will be able to handle interesting and non-trivial programs.</br></br>
			Here is an example Decaf program:
			<pre class="brush: cpp;">
			extern func print_int(int) void;

			package GreatestCommonDivisor {
				var a int = 10;
				var b int = 20;

				func main() int {
					var x, y, z int;
					x = a;
					y = b;
					z = gcd(x, y);

					// print_int is part of the standard input-output library
					print_int(z);
				}

				// function that computes the greatest common divisor
				func gcd(a int, b int) int {
					if (b == 0) { return(a); }
					else { return( gcd(b, a % b) ); }
				}
			}</pre>
		</div></br>
		The challenge of this course stemmed from learning the theoretical aspects of <a href="https://en.wikipedia.org/wiki/Lexical_analysis"><b>Lexical Analysis</b></a>, <a href="https://en.wikipedia.org/wiki/Parsing"><b>Grammar Parsing</b></a>, and <a href="https://en.wikipedia.org/wiki/Code_generation_(compiler)"><b>Code Generation</b></a>, then applying them to working code to design a complex system based off a set of specifications.
		The three main tools we used were:
		<ol>
			<li><a href="http://flex.sourceforge.net/" target="_parent"><b>Flex</b></a></li>
			<li><a href="https://www.gnu.org/software/bison/manual/" target="_parent"><b>YACC/Bison</b></li>
			<li><a href="http://llvm.org/" target="_parent"><b>LLVM</b></a></li>
		</ol>
		<div class="section">
			<h2 id="lex"><a href="#table-of-contents">Flex: Lexical Analyzer</a></h2>
			<h1 id="lex_regexp"><a href="#table-of-contents">Regular Expressions</a></h1>
			The main part of the Lexical Analyzer is composed of <a href="https://en.wikipedia.org/wiki/Regular_expression"><b>Regular Expressions</b></a>, a sequence of characters that define a search pattern, used in pattern matching with strings or string matching.</br></br>
			
			Simple examples of Regular Expressions are as follows:</br></br>
			<code>gr(a|e)y</code> : The word grey or gray, spelled either way </br></br>
			<code>[a-zA-Z]</code> : Lower & Uppercase Alphabetic characters </br></br>
			<code>[^a-zA-Z]</code> : Any characters that are NOT Lower & Uppercase Alphabetic characters ([^ ] : Any characters but the ones that follow) </br></br>
			<code>[a-zA-Z0-9]</code> : Alphanumeric characters</br></br>
			<code>(a|b)*</code> : Any number of the letters a or b in any order, or the empty string "" (* : Kleene Closure matches the preceding element(s) zero or more times)</br></br>
			<code>(a|b)*c</code> : Starting with any number of the letters a or b in any order, or the empty string "", and ends with the letter c</br></br>
			The topic of regular expressions is a broad subject, and the above barely scratches the surface of what they're capable of.</br>
			<h1 id="lex_decaf"><a href="#table-of-contents">Lexical Analyzer for Decaf</a></h1>
			Flex builds upon the the programming language C. The basic structure of a Flex program is demonstrated below:
			<pre class="brush: cpp;">
			%{ // Indicates to Flex that C syntax is going to be enclosed inside the {}

			#include &lt;iostream>
			using namespace std;
			int mylineno = 0;

			%}

			%option noyywrap // A Flex option to toggle a specific setting

			// Defining Regular Expressions into variables for use below
			string  \"[^\n"]+\" 
			alpha   [A-Za-z]
			dig     [0-9]

			%% // Indicates to Flex that the definition section of the program is ending, and the token definition section is beginning

			// Regular Expression         C Syntax to process the corresponding Regular Expression
			[{alpha}\_][{alpha}\_{dig}]*  { yylval.sval = new string(yytext); return T_ID; }
			{dig}{dig}*					  { yylval.number = conv_intconstant(yytext); return T_INTCONSTANT; }
			 
			%% // Indicates to Flex that the token definitions section is ending, and the main program is beginning

			int yyerror(const char *s) {
				cerr << lineno << ": " << s << " at char " << tokenpos << endl;
				return 1;
			}</pre>
			The main challenge of building a Lexical Analyzer was following the <a href="http://anoopsarkar.github.io/compilers-class/decafspec.html" target="_blank"><b>Decaf Specification</b></a> and building regular expressions for the following tokens:</br>
			<pre>
	T_AND            &&
	T_ASSIGN         =
	T_BOOLTYPE       bool
	T_BREAK          break
	T_CHARCONSTANT   char_lit (see section on Character literals)
	T_COMMA          ,
	T_COMMENT        comment
	T_CONTINUE       continue
	T_DIV            /
	T_DOT            .
	T_ELSE           else
	T_EQ             ==
	T_EXTERN         extern
	T_FALSE          false
	T_FOR            for
	T_FUNC           func
	T_GEQ            >=
	T_GT             >
	T_ID             identifier (see section on Identifiers)
	T_IF             if
	T_INTCONSTANT    int_lit (see section on Integer literals)
	T_INTTYPE        int
	T_LCB            {
	T_LEFTSHIFT      <<
	T_LEQ            <=
	T_LPAREN         (
	T_LSB            [
	T_LT             <
	T_MINUS          -
	T_MOD            %
	T_MULT           *
	T_NEQ            !=
	T_NOT            !
	T_NULL           null
	T_OR             ||
	T_PACKAGE        package
	T_PLUS           +
	T_RCB            }
	T_RETURN         return
	T_RIGHTSHIFT     >>
	T_RPAREN         )
	T_RSB            ]
	T_SEMICOLON      ;
	T_STRINGCONSTANT string_lit (see section on String literals)
	T_STRINGTYPE     string
	T_TRUE           true
	T_VAR            var
	T_VOID           void
	T_WHILE          while
	T_WHITESPACE     whitespace (see section on Whitespace)</pre>
	Building regular expressions for some of the above are easier than others. Below are a few samples, ranging from the easier ones to the harder ones.
	<ol>
		<li><b>Reserved Keywords</b></br>
			As one would expect, the regular expression for these tokens are the same as when typed in decaf, as such:
			<ul>
				<li>extern {return T_EXTERN;}</li>
				<li>return {return T_RETURN;}</li>
				<li>continue {return T_CONTINUE;}</li>
			</ul>
		</li></br>
		<li>
			<b>Variable Identifier</b></br>
			As in C, variable names can be any sequence of letters, numbers and the character '_' as long as it starts with a letter. The regular expression for this is:
			<ul>
				<li>[a-zA-Z\_][a-zA-Z\_0-9]*   { yylval.sval = new string(yytext); return T_ID; }</li>
			</ul></br>
			<b>Note:</b> In the regular expression, '\' indicates an escaped character in Flex, as '_' would otherwise be read as a Flex command.</br>yylval.sval defines a type that will be used in the Grammar Parser, and yytext is where the inputted variable name is stored. This allows the Grammar Parser to retrieve the variable name from the token T_ID when needed.
		</li></br>
		<li>
			<b>Escaped Characters In Character Literals</b></br>
			As in C, character literals are any characters enclosed in single quotes, ', and treated as an integer corresponding to their ASCII integer values. The regular expression for this is:</br>
			<pre class="brush: cpp;">
			[']([^\\n']|[\\][nrtvfab\\\'\"])['] { 
				char escape_check = yytext[1]; 
				char newvar = yytext[2]; 
				if(escape_check == '\\'){
					yylval.number = char_lit_esc_char(newvar);
				}
				else{
					yylval.number = yytext[1];
				} 
				return T_CHARCONSTANT;
			}</pre>
			In simpler terms, the regular expression above defines characters literals as:
			<code>`'` { char | escaped_char } `'`</code></br></br>
			Handling regular character literals is as easy as using the C function <a href="http://en.cppreference.com/w/cpp/string/byte/atoi" target="_blank"><b>atoi()</b></a>, which converts a single character to the corresponding ASCII integer value.</br></br>
			In order to handle escaped characters however, we opted to check whether or not it was an escaped character by looking for the '\' character in the first position. Given that was the case, then we used the char_lit_esc_char() function, which is defined as follows:
			<pre class="brush: cpp;">
			int char_lit_esc_char(char newvar){
				if(newvar == 'r'){
					return 13;
				}
				else if(newvar == 't'){
					return 9;
				}
				else if(newvar == 'f'){
					return 12;
				}
				else if(newvar == 'v'){
					return 11;
				}
				else if(newvar == 'n'){
					return 10;
				}
				else if(newvar == '\''){
					return 39;
				}
				else if(newvar == 'b'){
					return 8;
				}
				else if(newvar == 'a'){
					return 7;
				}
				else if(newvar == '\\'){
					return 92;
				}
				else if(newvar == '"'){
					return 34;
				}
				else{
					return atoi(yytext);
				}
			}</pre>
			Which determines what character is being escaped, and returning the corresponding ASCII integer value of the character.
		</li></br>
		<li>
			<b>Escaped Characters In String Literals</b></br>
			String literals are any sequence of characters inside of double quotes, "".This proved to be the most challenging regular expression to handle. Given that one wanted to express symbols such as ", \, or escaped characters such as new line (\n), tab (\t), etc. in a string, the lexical analyzer needs to recognise these situations and process them accordingly. As such, the regular expression for this is:</br></br>
			<ul>
				<li>\"([^\\"\n]|\\[nrtvfab\\'"])*\"	{ yylval.sval = esc_char(yytext); return T_STRINGCONSTANT; }</li>
			</ul></br>
			In simpler terms, the regular expression above defines string literals as:
			<code>`"` { char | escaped_char } `"`</code></br></br>
			The function esc_char() is defined as:</br>
			<pre class="brush: cpp;">
				string *esc_char(string os){
					string* s = new string(os);
					s->erase(0, 1);
					s->pop_back();
					int i = s->find("\\n");
					if(i != string::npos){
						const char* replace = "\n";
						s->replace(s->find("\\n"), 2, replace);
					}
					i = s->find("\\t");
					if(i != string::npos){
						const char* replace = "\t";
						s->replace(s->find("\\t"), 2, replace);
					}
					i = s->find("\\v");
					if(i != string::npos){
						const char* replace = "\v";
						s->replace(s->find("\\v"), 2, replace);
					}
					i = s->find("\\r");
					if(i != string::npos){
						const char* replace = "\r";
						s->replace(s->find("\\r"), 2, replace);
					}
					i = s->find("\\a");
					if(i != string::npos){
						const char* replace = "\a";
						s->replace(s->find("\\a"), 2, replace);
					}
					i = s->find("\\f");
					if(i != string::npos){
						const char* replace = "\f";
						s->replace(s->find("\\f"), 2, replace);
					}
					i = s->find("\\b");
					if(i != string::npos){
						const char* replace = "\b";
						s->replace(s->find("\\b"), 2, replace);
					}
					i = s->rfind("\\\"");
					if(i != string::npos){
						const char* replace = "\"";
						s->replace(s->find("\\\""), 2, replace);
					}
					i = s->find("\\\\");
					if(i != string::npos){
						const char* replace = "\\";
						s->replace(s->find("\\\\"), 2, replace);
					}
					return s;
				}</pre>
				The function esc_char() was defined to ensure that the correct sequence of characters was stored in the token. For example, without processing the initial string in esc_char(), the token would store the string "\\\"" as that sequence of characters, as opposed to storing the intended string of "\"".
		</li>
	</ol>
	<h1 id="lex_source"><a href="#table-of-contents">Source Code</a></h1>
	The source code for the Lexical Analyzer for Decaf can be found <a href="" target="_parent"><b>here</b></a>.
		</div>
		<div class="section">
			<h2 id="parser">YACC/Bison Grammar Parser</h2>
			<h1 id="parser_ast"> Abstract Syntax Tree</h1>
			An <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_parent"><b>Abstract Syntax Tree</b></a> (hereafter AST) is the resulting parse tree that is generated from a <a href="https://en.wikipedia.org/wiki/Context-free_grammar"><b>context free grammar</b></a> (hereafter CFG).</br></br>
			A common and simple example of an AST that can be generated from a CFG is given the CFG:</br>
			<pre>
		Rule 1: E -> E + T | T
		Rule 2: T -> T * F | F
		Rule 3: F -> [0-9]</pre>
			Which is a CFG that is expresses a single digit, or a sequence of products and sums, where a sum will be the right most expression.</br></br>
			An example of how an AST would be derived from this CFG is:
			<pre>
		Express: 1 * 2 + 3
		
		E -> E + T (Rule 1)
		E + T -> T + T (Rule 1)
		T + T -> T * F + T (Rule 2)
		T * F + T -> F * F + T (Rule 2)
		F * F + T -> 1 * F + T (Rule 3)
		1 * F + T -> 1 * 2 + T (Rule 3)
		1 * 2 + T -> 1 * 2 + F (Rule 2)
		1 * 2 + F -> 1 * 2 + 3 (Rule 3)</pre>
		The resulting tree from this grammar would be:</br>
		<img src="ast_example.png"/>
		<h1 id="parser_grammar"><a href="#table-of-contents">Grammar Parser for Decaf</a></h1>
		
		<h1 id="parser_source"><a href="#table-of-contents">Source Code</a></h1>
		The source code for the Grammar Parser for Decaf can be found <a href="" target="_parent"><b>here</b></a>.
		</div>
		<div class="section">
			<h2 id="codegen">LLVM Code Generation</h2>
		</div>
	</div>
</html>