<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<!-- To display C++ Code -->
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<script type="text/javascript" src="../syntax_highlighter/scripts/shCore.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushCpp.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushBash.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushPlain.js"></script>
		<link type="text/css" rel="stylesheet" href="../syntax_highlighter/styles/shCoreDefault.css"/>
		<script type="text/javascript">SyntaxHighlighter.all();</script>

		<link rel="stylesheet" type="text/css" href="../style.css"/>
		<style type="text/css">
		.arg1{color:red;}
		.arg2{color:green;}
		.arg3{color:blue;}
		.arg4{color:orange;}
		table{max-width: 500px;}
		</style>
		<title>Digital Portfolio of Correy Lim</title>
	</head>
	<body>
	<h3>CMPT 379: Principles In Compiler Design (May 2016 - August 2016)</h3>
	<div class="document">
		<div id="table-of-contents">
			<h2>Table of Contents</h2>
			<body>
			<div class="tableofcontents">
				<table>
					<li><a href="#preface">Preface</a></li>
					<ul>
						<li><a href="#proj_repo">Project Repository</a></li>
					</ul>
					<li><a href="#lex">Flex: Lexical Analyzer</a></li>
						<ul>
							<li><a href="#lex_regexp">Regular Expressions</a></li>
							<li><a href="#lex_decaf">Lexical Analyzer for Decaf</a></li>
							<li><a href="#lex_example01">Example of Lexical Analyzer for Decaf</a></li>
							<li><a href="#lex_source">Source Code</a></li>
						</ul>
					<li><a href="#parser">YACC/Bison Grammar Parser</a></li>
						<ul>
							<li><a href="#parser_ast">Abstract Syntax Tree</a></li>
							<li><a href="#parser_grammar">Grammar Parser for Decaf</a></li>
							<li><a href="#parser_example01">Example of Grammar Parser for Decaf</a></li>
							<li><a href="#parser_source">Source Code</a></li>
						</ul>
					<li><a href="#codegen">LLVM Code Generation</a></li>
					<ul>
						<li><a href="#codegen_ir">Intermediate Representation</a></li>
						<li><a href="#codegen_codegen">Code Generation for Decaf</a></li>
					</ul>
				</table>
			</div>
			</body>
		</div>
		<h2 id="preface">Preface</h2>
		In this course, my teammate and I were tasked with building a <a href="https://en.wikipedia.org/wiki/Compiler"><b>Compiler</b></a> for a C-like language created for the course, <a href="http://anoopsarkar.github.io/compilers-class/decafspec.html" target="_blank"><b>'Decaf'</b></a>.
		An exercept from the Decaf Specification page:</br></br>
		<div class="commandspec">
			Decaf is a strongly typed C-like language. The feature set is trimmed down considerably from what is usually part of a full-fledged programming language. This is done to keep the programming assignments manageable. Despite these limitations, Decaf will be able to handle interesting and non-trivial programs.</br></br>
			Here is an example Decaf program:
			<pre class="brush: cpp;">
			extern func print_int(int) void;

			package GreatestCommonDivisor {
				var a int = 10;
				var b int = 20;

				func main() int {
					var x, y, z int;
					x = a;
					y = b;
					z = gcd(x, y);

					// print_int is part of the standard input-output library
					print_int(z);
				}

				// function that computes the greatest common divisor
				func gcd(a int, b int) int {
					if (b == 0) { return(a); }
					else { return( gcd(b, a % b) ); }
				}
			}</pre>
		</div></br>
		The challenge of this course stemmed from learning the theoretical aspects of <a href="https://en.wikipedia.org/wiki/Lexical_analysis"><b>Lexical Analysis</b></a>, <a href="https://en.wikipedia.org/wiki/Parsing"><b>Grammar Parsing</b></a>, and <a href="https://en.wikipedia.org/wiki/Code_generation_(compiler)"><b>Code Generation</b></a>, then applying them to working code to design a complex system based off a set of specifications.
		The three main tools we used were:
		<ol>
			<li><a href="http://flex.sourceforge.net/" target="_parent"><b>Flex</b></a></li>
			<li><a href="https://www.gnu.org/software/bison/manual/" target="_parent"><b>YACC/Bison</b></li>
			<li><a href="http://llvm.org/" target="_parent"><b>LLVM</b></a></li>
		</ol>
		<div class="section">
			<h1 id="proj_repo">Project Repository</h1>
			All of the files for this project can be found <a href=""><b>here</b></a>.
			<h2 id="lex"><a href="#table-of-contents">Flex: Lexical Analyzer</a></h2>
			<h1 id="lex_regexp"><a href="#table-of-contents">Regular Expressions</a></h1>
			The main part of the Lexical Analyzer is composed of <a href="https://en.wikipedia.org/wiki/Regular_expression"><b>Regular Expressions</b></a>, a sequence of characters that define a search pattern, used in pattern matching with strings or string matching.</br></br>
			
			Simple examples of Regular Expressions are as follows:</br></br>
			<code>gr(a|e)y</code> : The word grey or gray, spelled either way </br></br>
			<code>[a-zA-Z]</code> : Lower & Uppercase Alphabetic characters </br></br>
			<code>[^a-zA-Z]</code> : Any characters that are NOT Lower & Uppercase Alphabetic characters ([^ ] : Any characters but the ones that follow) </br></br>
			<code>[a-zA-Z0-9]</code> : Alphanumeric characters</br></br>
			<code>(a|b)*</code> : Any number of the letters a or b in any order, or the empty string "" (* : Kleene Closure matches the preceding element(s) zero or more times)</br></br>
			<code>(a|b)*c</code> : Starting with any number of the letters a or b in any order, or the empty string "", and ends with the letter c</br></br>
			The topic of regular expressions is a broad subject, and the above barely scratches the surface of what they're capable of.</br>
			<h1 id="lex_decaf"><a href="#table-of-contents">Lexical Analyzer for Decaf</a></h1>
			Flex builds upon the the programming language C. The basic structure of a Flex program is demonstrated below:
			<pre class="brush: cpp;">
			%{ // Indicates to Flex that C syntax is going to be enclosed inside the {}

			#include &lt;iostream>
			using namespace std;
			int mylineno = 0;

			%}

			%option noyywrap // A Flex option to toggle a specific setting

			// Defining Regular Expressions into variables for use below 
			alpha   [A-Za-z]
			dig     [0-9]

			%% // Indicates to Flex that the definition section of the program is ending, and the token definition section is beginning

			// Regular Expression         C Syntax to process the corresponding Regular Expression
			[{alpha}\_][{alpha}\_{dig}]*  { yylval.sval = new string(yytext); return T_ID; }
			{dig}{dig}*					  { yylval.number = conv_intconstant(yytext); return T_INTCONSTANT; }
			= 							  { return T_ASSIGN; }
			;							  { return T_SEMICOLON; }
			 
			%% // Indicates to Flex that the token definitions section is ending, and the main program is beginning

			int yyerror(const char *s) {
				cerr << lineno << ": " << s << " at char " << tokenpos << endl;
				return 1;
			}</pre>
			The main challenge of building a Lexical Analyzer was following the <a href="http://anoopsarkar.github.io/compilers-class/decafspec.html" target="_blank"><b>Decaf Specification</b></a> and building regular expressions for the following tokens:</br>
			<pre>
	T_AND            &&
	T_ASSIGN         =
	T_BOOLTYPE       bool
	T_BREAK          break
	T_CHARCONSTANT   char_lit (see section on Character literals)
	T_COMMA          ,
	T_COMMENT        comment
	T_CONTINUE       continue
	T_DIV            /
	T_DOT            .
	T_ELSE           else
	T_EQ             ==
	T_EXTERN         extern
	T_FALSE          false
	T_FOR            for
	T_FUNC           func
	T_GEQ            >=
	T_GT             >
	T_ID             identifier (see section on Identifiers)
	T_IF             if
	T_INTCONSTANT    int_lit (see section on Integer literals)
	T_INTTYPE        int
	T_LCB            {
	T_LEFTSHIFT      <<
	T_LEQ            <=
	T_LPAREN         (
	T_LSB            [
	T_LT             <
	T_MINUS          -
	T_MOD            %
	T_MULT           *
	T_NEQ            !=
	T_NOT            !
	T_NULL           null
	T_OR             ||
	T_PACKAGE        package
	T_PLUS           +
	T_RCB            }
	T_RETURN         return
	T_RIGHTSHIFT     >>
	T_RPAREN         )
	T_RSB            ]
	T_SEMICOLON      ;
	T_STRINGCONSTANT string_lit (see section on String literals)
	T_STRINGTYPE     string
	T_TRUE           true
	T_VAR            var
	T_VOID           void
	T_WHILE          while
	T_WHITESPACE     whitespace (see section on Whitespace)</pre>
	Building regular expressions for some of the above are easier than others. Below are a few samples, ranging from the easier ones to the harder ones.
	<ol>
		<li><b>Reserved Keywords</b></br>
			As one would expect, the regular expression for these tokens are the same as when typed in decaf, as such:
			<ul>
				<li>extern {return T_EXTERN;}</li>
				<li>return {return T_RETURN;}</li>
				<li>continue {return T_CONTINUE;}</li>
			</ul>
		</li></br>
		<li>
			<b>Variable Identifier</b></br>
			As in C, variable names can be any sequence of letters, numbers and the character '_' as long as it starts with a letter. The regular expression for this is:
			<ul>
				<li>[a-zA-Z\_][a-zA-Z\_0-9]*   { yylval.sval = new string(yytext); return T_ID; }</li>
			</ul></br>
			<b>Note:</b> In the regular expression, '\' indicates an escaped character in Flex, as '_' would otherwise be read as a Flex command.</br>yylval.sval defines a type that will be used in the Grammar Parser, and yytext is where the inputted variable name is stored. This allows the Grammar Parser to retrieve the variable name from the token T_ID when needed.
		</li></br>
		<li>
			<b>Escaped Characters In Character Literals</b></br>
			As in C, character literals are any characters enclosed in single quotes, ', and treated as an integer corresponding to their ASCII integer values. The regular expression for this is:</br>
			<pre class="brush: cpp;">
			[']([^\\n']|[\\][nrtvfab\\\'\"])['] { 
				char escape_check = yytext[1]; 
				char newvar = yytext[2]; 
				if(escape_check == '\\'){
					yylval.number = char_lit_esc_char(newvar);
				}
				else{
					yylval.number = yytext[1];
				} 
				return T_CHARCONSTANT;
			}</pre>
			In simpler terms, the regular expression above defines characters literals as:
			<code>`'` { char | escaped_char } `'`</code></br></br>
			Handling regular character literals is as easy as using the C function <a href="http://en.cppreference.com/w/cpp/string/byte/atoi" target="_blank"><b>atoi()</b></a>, which converts a single character to the corresponding ASCII integer value.</br></br>
			In order to handle escaped characters however, we opted to check whether or not it was an escaped character by looking for the '\' character in the first position. Given that was the case, then we used the char_lit_esc_char() function, which is defined as follows:
			<pre class="brush: cpp;">
			int char_lit_esc_char(char newvar){
				if(newvar == 'r'){
					return 13;
				}
				else if(newvar == 't'){
					return 9;
				}
				else if(newvar == 'f'){
					return 12;
				}
				else if(newvar == 'v'){
					return 11;
				}
				else if(newvar == 'n'){
					return 10;
				}
				else if(newvar == '\''){
					return 39;
				}
				else if(newvar == 'b'){
					return 8;
				}
				else if(newvar == 'a'){
					return 7;
				}
				else if(newvar == '\\'){
					return 92;
				}
				else if(newvar == '"'){
					return 34;
				}
				else{
					return atoi(yytext);
				}
			}</pre>
			Which determines what character is being escaped, and returning the corresponding ASCII integer value of the character.
		</li></br>
		<li>
			<b>Escaped Characters In String Literals</b></br>
			String literals are any sequence of characters inside of double quotes, "".This proved to be the most challenging regular expression to handle. Given that one wanted to express symbols such as ", \, or escaped characters such as new line (\n), tab (\t), etc. in a string, the lexical analyzer needs to recognise these situations and process them accordingly. As such, the regular expression for this is:</br></br>
			<ul>
				<li>\"([^\\"\n]|\\[nrtvfab\\'"])*\"	{ yylval.sval = esc_char(yytext); return T_STRINGCONSTANT; }</li>
			</ul></br>
			In simpler terms, the regular expression above defines string literals as:
			<code>`"` { char | escaped_char } `"`</code></br></br>
			The function esc_char() is defined as:</br>
			<pre class="brush: cpp;">
				string *esc_char(string os){
					string* s = new string(os);
					s->erase(0, 1);
					s->pop_back();
					int i = s->find("\\n");
					if(i != string::npos){
						const char* replace = "\n";
						s->replace(s->find("\\n"), 2, replace);
					}
					i = s->find("\\t");
					if(i != string::npos){
						const char* replace = "\t";
						s->replace(s->find("\\t"), 2, replace);
					}
					i = s->find("\\v");
					if(i != string::npos){
						const char* replace = "\v";
						s->replace(s->find("\\v"), 2, replace);
					}
					i = s->find("\\r");
					if(i != string::npos){
						const char* replace = "\r";
						s->replace(s->find("\\r"), 2, replace);
					}
					i = s->find("\\a");
					if(i != string::npos){
						const char* replace = "\a";
						s->replace(s->find("\\a"), 2, replace);
					}
					i = s->find("\\f");
					if(i != string::npos){
						const char* replace = "\f";
						s->replace(s->find("\\f"), 2, replace);
					}
					i = s->find("\\b");
					if(i != string::npos){
						const char* replace = "\b";
						s->replace(s->find("\\b"), 2, replace);
					}
					i = s->rfind("\\\"");
					if(i != string::npos){
						const char* replace = "\"";
						s->replace(s->find("\\\""), 2, replace);
					}
					i = s->find("\\\\");
					if(i != string::npos){
						const char* replace = "\\";
						s->replace(s->find("\\\\"), 2, replace);
					}
					return s;
				}</pre>
				The function esc_char() was defined to ensure that the correct sequence of characters was stored in the token. For example, without processing the initial string in esc_char(), the token would store the string "\\\"" as that sequence of characters, as opposed to storing the intended string of "\"".
		</li>
	</ol>
	<h1 id="lex_example01"><a href="#table-of-contents">Example of Lexical Analyzer for Decaf</a></h1>
	The following are a couple of sample decaf programs, and what the Lexical Analyzer passes to the Grammar Parser:
	<pre class="brush: cpp;">
	// assign.decaf
	package C {
	func f() void {
			var x int;
			x = 1;
		}
	}</pre>
	The lexical analyzer would return:
	<pre>
	T_PACKAGE package
	T_ID C
	T_LCB {
	T_FUNC func
	T_ID f
	T_LPAREN (
	T_RPAREN )
	T_VOID void
	T_LCB {
	T_VAR var
	T_ID x
	T_INT int
	T_SEMICOLON ;
	T_ID x
	T_ASSIGN =
	T_INTCONSTANT 1
	T_SEMICOLON ;
	T_RCB }
	T_RCB }</pre>
	<pre class="brush: cpp;">
	// stringconst1.decaf
	extern func print_string(string) void;

	package Test {
		func main() int {
			print_string("hello, world\n");
		}
	}</pre>
	The lexical analyzer would return:
	<pre>	T_EXTERN extern
	T_FUNC func
	T_ID print_string
	T_LPAREN (
	T_STRINGTYPE string
	T_RPAREN )
	T_VOID void
	T_SEMICOLON ;
	T_PACKAGE package
	T_ID Test
	T_LCB {
	T_FUNC func
	T_ID main
	T_LPAREN (
	T_RPAREN )
	T_INTTYPE int
	T_LCB {
	T_ID print_string
	T_LPAREN (
	T_STRINGCONSTANT "hello, world"
	T_RPAREN )
	T_SEMICOLON ;
	T_RCB }
	T_RCB }</pre>
	<h1 id="lex_source"><a href="#table-of-contents">Source Code</a></h1>
	The source code for the Lexical Analyzer for Decaf can be found <a href="" target="_parent"><b>here</b></a>.
		</div>
		<div class="section">
			<h2 id="parser">YACC/Bison Grammar Parser</h2>
			<h1 id="parser_ast"> Abstract Syntax Tree</h1>
			An <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_parent"><b>Abstract Syntax Tree</b></a> (hereafter AST) is the resulting parse tree that is generated from a <a href="https://en.wikipedia.org/wiki/Context-free_grammar"><b>context free grammar</b></a> (hereafter CFG).</br></br>
			A common and simple example of an AST that can be generated from a CFG is given the CFG:</br>
			<pre>
		Rule 1: E -> E + T | T
		Rule 2: T -> T * F | F
		Rule 3: F -> [0-9]</pre>
			Which is a CFG that is expresses a single digit, or a sequence of products and sums, where a sum will be the right most expression.</br></br>
			An example of how an AST would be derived from this CFG is:
			<pre>
		Express: 1 * 2 + 3
		
		E -> E + T (Rule 1)
		E + T -> T + T (Rule 1)
		T + T -> T * F + T (Rule 2)
		T * F + T -> F * F + T (Rule 2)
		F * F + T -> 1 * F + T (Rule 3)
		1 * F + T -> 1 * 2 + T (Rule 3)
		1 * 2 + T -> 1 * 2 + F (Rule 2)
		1 * 2 + F -> 1 * 2 + 3 (Rule 3)</pre>
		The resulting tree from this grammar would be:</br>
		<img src="ast_example.png"/>
		<h1 id="parser_grammar"><a href="#table-of-contents">Grammar Parser for Decaf</a></h1>
		YACC/Bison builds on the programming language C++. The basic structure of a YACC/Bison program is as follows:</br>
		(Note that this builds upon the example .lex file as shown in <a href="#lex_decaf"><b>Lexical Analyzer for Decaf</b></a>)
		<pre class="brush: cpp;">
		%{ // Initial variable definitions, including the beginning C++ include/using statements
		#include &lt;iostream>
		#include &lt;ostream>
		#include &lt;string>
		#include &lt;cstdlib>

		int yylex(void);
		int yyerror(char *); 

		#include "default.cc"

		using namespace std;

		%} // Links the tokens defined in the .lex file (the Lexical Analyzer)

		%union{
			class decafAST *ast;
			std::string *sval;
		}

		%token &lt;sval> T_ID
		%token T_INTCONSTANT
		%token T_ASSIGN
		%token T_SEMICOLON

		%% // CFG definitions begin

		start: assign // Indicates to Flex how the start of a program using this grammar should be

		assign: T_ID T_ASSIGN T_INTCONSTANT T_SEMICOLON // The definition of the expression 'assign', which is composed of the indicated tokens
				{ 
					$$ = new AssignVarAST(*$1, $3); // Calling the function that creates the AST for an assign expression
				}

		%% // Main YACC/Bison Program begins

		int main() {
			// parse the input and create the abstract syntax tree
			int retval = yyparse();
			return(retval >= 1 ? EXIT_FAILURE : EXIT_SUCCESS);
		}</pre>
		The Grammar Parser for Decaf builds ASTs by using <a href="http://www.cplusplus.com/doc/tutorial/polymorphism/" target="_parent"><b>C++ Polymorphism</b></a>, where decafAST is the base class:
		<pre class="brush: cpp;">
		/// decafAST - Base class for all abstract syntax tree nodes.
		class decafAST {
		public:
			virtual ~decafAST() {}
			virtual string str() { return string(""); }
			virtual llvm::Value *Codegen() = 0;
		};</pre>
		And to build on the initial example, the AssignVarAST() function is defined as:
		<pre class="brush: cpp;">
		class AssignVarAST : public decafAST { // Note the use of Polymorphism
			string VarName;
			decafAST *Expression;
			public:
			AssignVarAST(string varname, decafAST *expression) : VarName(varname), Expression(expression) {}
			~AssignVarAST() {
				if (Expression != NULL) { delete Expression; }
			}
			string str() { return string("AssignVar") + "(" + VarName + "," + getString(Expression) + ")"; }
		};</pre>
		Note that if the function str() inside AssignVarAST is called, then it will print out it's specific AST. For example, if it were given the arguments:
		<pre class="brush: cpp;">
		AssignVarAST(x, 10);</pre>
		Then the returned string would be:</br></br>
		<code>AssignVar(x,10)</code></br></br>
		As such, every expression needs its own defined AST class, which can be found in <a href=""><b>decafcomp.cc</b></a></br></br>
		Notable challenges when implementing the Grammar Parser was handling multiple ways to define the same action. For example, as is valid in C++, Decaf supports typecasting multiple variables in one line, in addition to other variable declarations on separate lines, like so:
		<pre class="brush: cpp;">
		var a bool;
		var b int;
		var x, y, z int // The equivalent of int x,y,z in C/C++</pre>
		Handling the multiple lines of variable definitions require utilizing the class decafStmtList, which is a list of Decaf ASTs:
		<pre class="brush: cpp;">
		class decafStmtList : public decafAST {
			list&lt;decafAST *> stmts;
			public:
				decafStmtList() {}
				~decafStmtList() {
					for (list&lt;decafAST *>::iterator i = stmts.begin(); i != stmts.end(); i++) {
						delete *i;
					}
				}
				int size() { return stmts.size(); }
				void push_front(decafAST *e) { stmts.push_front(e); }
				void push_back(decafAST *e) { stmts.push_back(e); }
				string str() { return commaList&lt;class decafAST *>(stmts); }
		};
		
		// ...
		
		field_decl_list: field_decl_list field_decl // Notice how this expression is left recursive
			{ decafStmtList *slist = (decafStmtList *)$1; slist->push_back($2); $$ = slist; }
		| /* empty */
			{ decafStmtList *slist = new decafStmtList(); $$ = slist; }
		;</pre>
		Then to handle multiple variable definitions on the same line, we needed to create a new class, IdList:
		<pre class="brush: cpp;">
		class IdList : public decafAST {
			list&lt;class decafAST *> Vars;
			string Type;
			int Size;

			public:
				IdList(){}
				IdList(string name, string type, int size){
					Type = type;
					Size = size;
					FieldDeclAST *temp = new FieldDeclAST(name, Type, Size);
					Vars.push_front(temp);
				}
				~IdList(){}

				void push_front(string name, string type, int size){
					FieldDeclAST *temp = new FieldDeclAST(name, type, size);
					Vars.push_front(temp);
				}
				void push_back(string name, string type, int size){
					FieldDeclAST *temp = new FieldDeclAST(name, type, size);
					Vars.push_back(temp);
				}
				void addVar(string name) {
					FieldDeclAST *temp = new FieldDeclAST(name, Type, Size);
					Vars.push_front(temp);
				}
				virtual llvm::Value* Codegen();
				string str(){ return commaList&lt;class decafAST *>(Vars);}
		};
		
		// ... 
		
		field_decl: T_VAR id_list T_SEMICOLON { $$ = $2; } // Notice how the actual variable names are not defined in this expression, but a separate expression, id_list, instead

		id_list: T_ID decaf_type { // The parser reads from right to left, so we instantiate the list here, and push on to it every variable declared on the same line
				$$ = new IdList(*$1, *$2, -1); 
			}
			| T_ID T_COMMA id_list { 
					IdList *temp = (IdList*)$3;
					temp->addVar(*$1); $$ = temp;
			}</pre>
		<h1 id="parser_example01"><a href="#table-of-contents">Example of Grammar Parser for Decaf</a></h1>
		To build upon the previous examples in <a href="#lex_example01"><b>'Example of Lexical Analyzer for Decaf'</b></a>:
		<pre class="brush: cpp;">
		// assign.decaf
		package C {
		func f() void {
				var x int;
				x = 1;
			}
		}</pre>
		The grammar parser would return:
		<pre>
	Program(None,Package(
			C,None,Method(
				f,VoidType,None,MethodBlock(
					None,AssignVar(
						x,NumberExpr(1)
					)
				)
			)
		)
	)</pre>
		<pre class="brush: cpp;">
		// stringconst1.decaf
		extern func print_string(string) void;

		package Test {
			func main() int {
				print_string("hello, world\n");
			}
		}</pre>
		The grammar parser would return:
		<pre>
	Program(ExternFunction(
		print_string,VoidType,VarDef("hello, world!\n",StringType)
	),Package(Test,None,None))</pre>
		<h1 id="parser_source"><a href="#table-of-contents">Source Code</a></h1>
		The source code for the Grammar Parser for Decaf can be found <a href="" target="_parent"><b>here</b></a>.
		</div>
		<div class="section">
			<h2 id="codegen">LLVM Code Generation</h2>
			<h1 id="codegen_ir"><a href="#table-of-contents">Intermediate Representation</a></h1>
			We used LLVM to generate an <a href="https://en.wikipedia.org/wiki/Intermediate_representation" target="_parent"><b>Intermediate Representation</b></a>, which in terms of complexity falls in between high-level languages (such as C/C++) and low-level languages (such as assembly). A sample LLVM program is as follows:
			<pre class="brush: plain;">
			define void @f() {
			entry:
				%x = alloca i32 ; Allocating memory for the variable x for a 32-bit integer
				store i32 1, i32* %x ; Storing the value 1 into the variable x
				ret void
			}</pre>
			Using the LLVM Library proved to be the most challenging part of the course, <a href="http://llvm.org/docs/doxygen/html/classes.html" target="_parent"><b>as the LLVM API is quite large</b></a>.
			<h1 id="codegen_codegen"><a href="#table-of-contents">Code Generation for Decaf</a></h1>
			Within the base class decafAST(), we added a virtual function 'codegen()':
			<pre class="brush: cpp;">
			class decafAST {
			public:
				virtual ~decafAST() {}
				virtual string str() { return string(""); }
				virtual llvm::Value *Codegen() = 0;
			};</pre>
			The Compiler traverses the generated AST, and when an AST object has its codegen() function called, the LLVM library is utilized to generate the associated code.</br></br>
			To build on the example of assign.decaf, I've modified the code slightly:
			<pre class="brush: cpp;">
			// assign.decaf
			extern func print_int(int) void; // Importing the function print_int() from the Decaf Standard Library
			package C {
				func f() void { // Defining the function f()
					var x int;
					x = 1;
					print_int(x);
				}
				func main() int{ // Defining the main() function
					func f(); // Calling f(), defined above
				}
			}</pre>
			Note how I've added a call to define the externally defined print_int() from the Decaf Standard Library, added print_int() inside of the f() definition, defined a main() function and call f() inside of it.</br></br>
			The expected output from this program after it has been compiled and run should be:</br></br>
			<code>1</code></br></br>
			To walk through the code, we begin with PackageAST():
			<pre class="brush: cpp;">
			decafpackage: T_PACKAGE T_ID T_LCB field_decl_list method_decl_list T_RCB
			{ $$ = new PackageAST(*$2, (IdList *)$4, (decafStmtList *)$5);
				symtable->new_symtbl(); // For FieldDeclList (Global Sym Table)
				tablenumber++;
				$4->Codegen();
				$5->Codegen();
				if(SavingMain != NULL){SavingMain->Codegen();}
				symtable->remove_symtbl();
				tablenumber--;
				delete $2;
			}</pre>
			The most important aspect of the above code is line 6, wherein $5 (method_decl_list) has its codegen() function called. Method_decl_list is a list of method_decl, which is defined as:
			<pre class="brush: cpp;">
			method_decl: T_FUNC T_ID T_LPAREN method_var_list T_RPAREN method_type method_block {
				if(*$2 == "main"){
					SavingMain = new MethodDeclAST(*$2, *$6, (MethodVarListAST *)$4, (MethodBlockAST *)$7);
					$$ = SavingMain;
				}
				else{
					$$ = new MethodDeclAST(*$2, *$6, (MethodVarListAST *)$4, (MethodBlockAST *)$7);
				}
				delete $2;
			}
			;</pre>
			In this case, two MethodDeclAST objects are created, one for f() and one for main().</br></br>
			For both, the same codegen() function is called:
			<pre class="brush: cpp;">
			Value* MethodDeclAST::Codegen() {
				symtable->new_symtbl(); // Creates a new symbol table since we're entering a new block of code
				if (Name == "main"){ // The function being defined is main()
					gen_main_def();
				}
				else{ // The function being defined is not main, thus we need to retrieve its arguments, if any
					list&lt;Value*> ArgTypes;
					vector&lt;string> ArgNames;
					MethodVarsList->FillOutArgs(ArgTypes, ArgNames); // Needed for functionArgs push_back Type* (either bool or int)

					FunctionProtos[Name] = gen_function_def(ArgTypes, Name, methodType, ArgNames, MBlock); // NeededForFunctionArgs & FunctionArgsName is passed by reference, so we don't need to empty it
				}
				// ...
			}</pre>
			gen_function_def() is defined as follows:
			<pre class="brush: cpp;">
			llvm::Function *gen_function_def(list<Value*> &FunctionArgs, string FunctionName, string FunctionType, vector<string> &FunctionArgsName, MethodBlockAST* mblock){
			llvm::FunctionType *FT;
				vector<Type*> FunctionArgTypes;
				int i = 0;
				list<Value*> AllocaFuncArgs;
				while( !FunctionArgs.empty() ){
					//Changing all function args to back temp
					FunctionArgTypes.push_back(FunctionArgs.front()->getType());
					AllocaFuncArgs.push_back(FunctionArgs.front());
					FunctionArgs.pop_front();
				}
				FT = get_function_type(FunctionType, FunctionArgTypes);
				/*FUNCTION DECLARATION*/
				llvm::Function *TheFunction = llvm::Function::Create(FT, llvm::Function::ExternalLinkage, FunctionName, TheModule);
				if (TheFunction->getName() != FunctionName){
					TheFunction->eraseFromParent();
					TheFunction = TheModule->getFunction(FunctionName);
					if (!TheFunction->empty()){
						throw runtime_error("ERROR: redefinition of function");
						//return 0;
					}
				}
				if (TheFunction == 0) {
					throw runtime_error("empty function block");
				}
				setFuncArgs(TheFunction, FunctionArgsName);
				// Create a new basic block which contains a sequence of LLVM instructions
				llvm::BasicBlock *BB = llvm::BasicBlock::Create(llvm::getGlobalContext(), "entry", TheFunction);
				// All subsequent calls to IRBuilder will place instructions in this location
				Builder.SetInsertPoint(BB);
				while( !AllocaFuncArgs.empty() ){
					AllocaInst* Alloca;
					llvm::Type* tempType = AllocaFuncArgs.front()->getType();
					Alloca = defineVariable(tempType, FunctionArgsName[i]);
					AllocaFuncArgs.pop_front();
					i++;
				}
				llvm::BasicBlock *CurBB = Builder.GetInsertBlock();
				//Gives you a link to the current basic block
				llvm::Function *func = Builder.GetInsertBlock()->getParent();

				verifyFunction(*TheFunction);
				return TheFunction;
			}</pre>
			While complicated due to the nature of the LLVM API, calling gen_function_def() generates the function definition in LLVM, resulting in:
			<pre class="brush: plain;">
			define void @f() {
				entry:
				; Note that the insertion point is here, so when the block of code inside the function declaration for f() 
				; has its codegen() function run, all of it will go in here.
			}</pre>
			<pre class="brush: cpp;">
			Value* MethodDeclAST::Codegen() {
				// ...
				Value* ReturnTy = MBlock->Codegen(); // Performing the codegen for the block of code within the function declaration
				if(methodType == "VoidType"){
					Builder.CreateRet(NULL);
				}
				symtable->remove_symtbl(); // Exiting a block of code, need to remove the symbol table
				Builder.ClearInsertionPoint(); // Tells LLVM to stop writing code in for this block
			}</pre>
			Note how a call to codegen() is done inside a codegen() definition. This recursive nature of calling codegen() is how we're able to traverse the AST with only a single call. This recursive codegen() call generates the body of the function in LLVM. To see how it specifically does that, we need to look at MBlock->Codegen, which is of the type BlockAST::Codegen():</br></br>
			<pre class="brush: cpp;">
			Value* BlockAST::Codegen() {
				symtable->new_symtbl();
				tablenumber++;
				BlockVarDefs->Codegen();
				BlockStatementList->Codegen();
				symtable->remove_symtbl();
				tablenumber--;
			}</pre>
			Once again, note the recursive Codegen() calls. It is important to note that Decaf requires all variable declarations to be done before any statements can be called, unlike many programming languages where variable and statements can be done interchangably. BlockVarDefs->Codegen() calls the MethodVarListAST::Codegen() definition:</br>
			<pre class="brush: cpp;">
			Value* MethodVarListAST::Codegen() {
				AllocaInst *Alloca;
				errstr("MethodVarList, MethodVars.size() = " + to_string(MethodVars.size()));
				while(MethodVars.size() != 0){
					VarDefAST* vd = getFront();
					errstr("MethodVarListAST VarDef: Name = " + vd->Name + ", Type: " + vd->VarType);
					if(retrieve_front_type()=="IntType"){
						errstr("MethodVarList IntType Store Alloca in table " + to_string(tablenumber));
						Alloca = Builder.CreateAlloca(Type::getInt32Ty(getGlobalContext()), nullptr, retrieve_front());
						Builder.CreateStore(Builder.getInt32(0), Alloca); // Zero initialize
					}
					else if(retrieve_front_type()=="BoolType"){
						Alloca = Builder.CreateAlloca(Type::getInt1Ty(getGlobalContext()), nullptr, retrieve_front());
						Builder.CreateStore(Builder.getInt1(0), Alloca); // Zero initialize
						errstr("MethodVarList BoolType Store Alloca in table " + to_string(tablenumber));
					}
					else{
						throw runtime_error("This type is not recognised.");
					}
					descriptor* temp = new descriptor; // Adding the variable to the symbol table
					temp->lineno = lineno;
					temp->mem_loca = Alloca;
					symtable->enter_symtbl(retrieve_front(), temp);
					errstr("Added symbol " + retrieve_front() + " in table " + to_string(tablenumber));
					MethodVars.pop_front();
				}
			}</pre>
			The resulting LLVM code is now:
			<pre class="brush: plain;">
			define void @f() {
			entry:
				%x = alloca i32
				store i32 0, i32* %x ; All variables in Decaf are zero initialized
			}</pre>
			Next, BlockStatementList->Codegen() is done. Since there are two statements,
			<pre class="brush: cpp;">
			x = 1;
			print_int(x);</pre>
			Two Codegen() definitions will be called:
			<pre class="brush: cpp;">
			Value* AssignVarAST::Codegen() {
				descriptor* temp = NULL;
				llvm::Value *V = Expression->Codegen();
				setValue(V);
				temp = symtable->access_symtbl(VarName);
				if(temp == NULL){throw runtime_error("AssignVarAST::This variable has not been declared.");}
				llvm::AllocaInst* Alloca = temp->mem_loca;
				Builder.CreateStore(Val, Alloca);
				errstr("AssignVarAST CreateStore " + VarName);
			}
			
			// ...
			
			class MethodCallAST : public decafAST{
				string MethodName;
				decafStmtList* Expression;
				public:
				MethodCallAST(string methodname, decafStmtList* expression) : MethodName(methodname), Expression(expression) {}
				~MethodCallAST(){
					if (Expression != NULL){
							delete Expression;
					}
				}
				virtual Value* Codegen();
				decafStmtList* returnArgs(){
					return Expression;
				}
				string str() { return string("MethodCall") + "(" + MethodName + "," + getString(Expression) + ")"; }
			};</pre>
			Note that MethodCallAST::Codegen() has recursive Codegen() calls as well, which simply retrieves the variable being called in its argument, in this case x:
			<pre class="brush: cpp">
			Value* VariableExprAST::Codegen() {
			descriptor* access = symtable->access_symtbl(Value);
			if( access != NULL ){
				llvm::Value *V;
				if(access->mem_loca != NULL){
					V = access->mem_loca;
				}
				else{
					V = access->globvar_mem_loca;
				}
				errstr("VariableExpr create Load " + Value);
				return Builder.CreateLoad(V,Value);
			}
			else{
				throw runtime_error("VariableExprAST: This variable has not been defined inside the Symbol Table");</pre>
			<h1>Symbol Tables</h1>
			<h1>Control Flow Graph</h1>
			<h1 id="codegen_source">Source Code</h1>
			The source code for the Code Generation can be found <a href=""><b>here</b></a>.
		</div>
	</div>
</html>