<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<!-- To display C++ Code -->
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<script type="text/javascript" src="../syntax_highlighter/scripts/shCore.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushCpp.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushBash.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushPlain.js"></script>
		<link type="text/css" rel="stylesheet" href="../syntax_highlighter/styles/shCoreDefault.css"/>
		<script type="text/javascript">SyntaxHighlighter.all();</script>

		<link rel="stylesheet" type="text/css" href="../style.css"/>
		<style type="text/css">
		.arg1{color:red;}
		.arg2{color:green;}
		.arg3{color:blue;}
		.arg4{color:orange;}
		table{max-width: 500px;}
		</style>
		<title>Digital Portfolio of Correy Lim</title>
	</head>
	<body>
	<h3>CMPT 379: Principles In Compiler Design (May 2016 - August 2016)</h3>
	<div class="document">
		<div id="table-of-contents">
			<h2>Table of Contents</h2>
			<body>
			<div class="tableofcontents">
				<table>
					<li><a href="#preface">Preface</a></li>
					<li><a href="#lex">Flex: Lexical Analyzer</a></li>
						<ul>
							<li><a href="#lex_regexp">Regular Expressions</a></li>
							<li><a href="#lex_decaf">Lexical Analyzer for Decaf</a></li>
							<li><a href="#lex_source">Source Code</a></li>
						</ul>
					<li><a href="#parser">YACC/Bison Grammar Parser</a></li>
					<li><a href="#codegen">LLVM Code Generation</a></li>
					<ul>
					</ul>
				</table>
			</div>
			</body>
		</div>
		<h2 id="preface">Preface</h2>
		In this course, my teammate and I were tasked with building a <a href="https://en.wikipedia.org/wiki/Compiler"><b>Compiler</b></a> for a C-like language created for the course, <a href="http://anoopsarkar.github.io/compilers-class/decafspec.html" target="_blank"><b>'Decaf'</b></a>.
		An exercept from the Decaf Specification page:</br></br>
		<div class="commandspec">
			Decaf is a strongly typed C-like language. The feature set is trimmed down considerably from what is usually part of a full-fledged programming language. This is done to keep the programming assignments manageable. Despite these limitations, Decaf will be able to handle interesting and non-trivial programs.</br></br>
			Here is an example Decaf program:
			<pre class="brush: cpp;">
			extern func print_int(int) void;

			package GreatestCommonDivisor {
				var a int = 10;
				var b int = 20;

				func main() int {
					var x, y, z int;
					x = a;
					y = b;
					z = gcd(x, y);

					// print_int is part of the standard input-output library
					print_int(z);
				}

				// function that computes the greatest common divisor
				func gcd(a int, b int) int {
					if (b == 0) { return(a); }
					else { return( gcd(b, a % b) ); }
				}
			}</pre>
		</div></br>
		The challenge of this course stemmed from learning the theoretical aspects of <a href="https://en.wikipedia.org/wiki/Lexical_analysis"><b>Lexical Analysis</b></a>, <a href="https://en.wikipedia.org/wiki/Parsing"><b>Grammar Parsing</b></a>, and <a href="https://en.wikipedia.org/wiki/Code_generation_(compiler)"><b>Code Generation</b></a>, then applying them to working code to design a complex system based off a set of specifications.
		The three main tools we used were:
		<ol>
			<li><a href="http://flex.sourceforge.net/" target="_parent"><b>Flex</b></a></li>
			<li><a href="https://www.gnu.org/software/bison/manual/" target="_parent"><b>YACC/Bison</b></li>
			<li><a href="http://llvm.org/" target="_parent"><b>LLVM</b></a></li>
		</ol>
		<div class="section">
			<h2 id="lex">Flex: Lexical Analyzer</h2>
			<h1 id="lex_regexp">Regular Expressions</h1>
			The main part of the Lexical Analyzer is composed of <a href="https://en.wikipedia.org/wiki/Regular_expression"><b>Regular Expressions</b></a>, a sequence of characters that define a search pattern, used in pattern matching with strings or string matching.</br></br>
			
			Simple examples of Regular Expressions are as follows:</br></br>
			<code>gr(a|e)y</code> : The word grey or gray, spelled either way </br></br>
			<code>[a-zA-Z]</code> : Lower & Uppercase Alphabetic characters </br></br>
			<code>[^a-zA-Z]</code> : Any characters that are NOT Lower & Uppercase Alphabetic characters ([^ ] : Any characters but the ones that follow) </br></br>
			<code>[a-zA-Z0-9]</code> : Alphanumeric characters</br></br>
			<code>(a|b)*</code> : Any number of the letters a or b in any order, or the empty string "" (* : Kleene Closure matches the preceding element(s) zero or more times)</br></br>
			<code>(a|b)*c</code> : Starting with any number of the letters a or b in any order, or the empty string "", and ends with the letter c</br>
			
			<h1 id="lex_decaf">Lexical Analyzer for Decaf</h1>
			The topic of regular expressions is a broad subject, and the above barely scratches the surface of what they're capable of.</br></br>
			
			The main challenge of building a Lexical Analyzer was following the <a href="http://anoopsarkar.github.io/compilers-class/decafspec.html" target="_blank"><b>Decaf Specification</b></a> and building regular expressions for the following tokens:</br>
			<pre>
	T_AND            &&
	T_ASSIGN         =
	T_BOOLTYPE       bool
	T_BREAK          break
	T_CHARCONSTANT   char_lit (see section on Character literals)
	T_COMMA          ,
	T_COMMENT        comment
	T_CONTINUE       continue
	T_DIV            /
	T_DOT            .
	T_ELSE           else
	T_EQ             ==
	T_EXTERN         extern
	T_FALSE          false
	T_FOR            for
	T_FUNC           func
	T_GEQ            >=
	T_GT             >
	T_ID             identifier (see section on Identifiers)
	T_IF             if
	T_INTCONSTANT    int_lit (see section on Integer literals)
	T_INTTYPE        int
	T_LCB            {
	T_LEFTSHIFT      <<
	T_LEQ            <=
	T_LPAREN         (
	T_LSB            [
	T_LT             <
	T_MINUS          -
	T_MOD            %
	T_MULT           *
	T_NEQ            !=
	T_NOT            !
	T_NULL           null
	T_OR             ||
	T_PACKAGE        package
	T_PLUS           +
	T_RCB            }
	T_RETURN         return
	T_RIGHTSHIFT     >>
	T_RPAREN         )
	T_RSB            ]
	T_SEMICOLON      ;
	T_STRINGCONSTANT string_lit (see section on String literals)
	T_STRINGTYPE     string
	T_TRUE           true
	T_VAR            var
	T_VOID           void
	T_WHILE          while
	T_WHITESPACE     whitespace (see section on Whitespace)</pre>
		</div>
		<div class="section">
			<h2 id="parser">YACC/Bison Grammar Parser</h2>
		</div>
		<div class="section">
			<h2 id="codegen">LLVM Code Generation</h2>
		</div>
	</div>
</html>