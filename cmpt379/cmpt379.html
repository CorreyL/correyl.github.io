<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<!-- To display C++ Code -->
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<script type="text/javascript" src="../syntax_highlighter/scripts/shCore.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushCpp.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushBash.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushPlain.js"></script>
		<link type="text/css" rel="stylesheet" href="../syntax_highlighter/styles/shCoreDefault.css"/>
		<script type="text/javascript">SyntaxHighlighter.all();</script>

		<link rel="stylesheet" type="text/css" href="../style.css"/>
		<style type="text/css">
		.arg1{color:red;}
		.arg2{color:green;}
		.arg3{color:blue;}
		.arg4{color:orange;}
		table{max-width: 500px;}
		</style>
		<title>Digital Portfolio of Correy Lim</title>
	</head>
	<body>
	<h3>CMPT 379: Principles In Compiler Design (May 2016 - August 2016)</h3>
	<div class="document">
		<div id="table-of-contents">
			<h2>Table of Contents</h2>
			<body>
			<div class="tableofcontents">
				<table>
					<li><a href="#preface">Preface</a></li>
					<ul>
						<li><a href="#proj_repo">Project Repository</a></li>
					</ul>
					<li><a href="#lex">Flex: Lexical Analyzer</a></li>
						<ul>
							<li><a href="#lex_regexp">Regular Expressions</a></li>
							<li><a href="#lex_decaf">Lexical Analyzer for Decaf</a></li>
							<li><a href="#lex_example01">Example of Lexical Analyzer for Decaf</a></li>
							<li><a href="#lex_source">Source Code</a></li>
						</ul>
					<li><a href="#parser">YACC/Bison Grammar Parser</a></li>
						<ul>
							<li><a href="#parser_ast">Abstract Syntax Tree</a></li>
							<li><a href="#parser_grammar">Grammar Parser for Decaf</a></li>
							<li><a href="#parser_example01">Example of Grammar Parser for Decaf</a></li>
							<li><a href="#parser_source">Source Code</a></li>
						</ul>
					<li><a href="#codegen">LLVM Code Generation</a></li>
					<ul>
						<li><a href="#codegen_ir">Intermediate Representation</a></li>
						<li><a href="#codegen_symboltable">Symbol Tables</a></li>
						<li><a href="#codegen_codegen">Code Generation for Decaf</a></li>
						<li><a href="#codegen_source">Source Code</a></li>
					</ul>
					<li><a href="#compiler_example00">Examples of Decaf Compiler</a></li>
					<ul>
						<li><a href="#compiler_example01">Greatest Common Divisor (Recursive Function)</a></li>
						<li><a href="#compiler_example02">Chaining Function Calls</a></li>
						<li><a href="#compiler_example03">Boolean Short Circuiting</a></li>
					</ul>
				</table>
			</div>
			</body>
		</div>
		<h2 id="preface">Preface</h2>
		(<b>NOTE:</b> Due to the complex nature of this project and for the sake of brevity, only the basics of how it works will be covered.)</br></br>
		In this course, my teammate and I were tasked with building a <a href="https://en.wikipedia.org/wiki/Compiler"><b>Compiler</b></a> for a C-like language created for the course, <a href="http://anoopsarkar.github.io/compilers-class/decafspec.html" target="_blank"><b>'Decaf'</b></a>.
		An exercept from the Decaf Specification page:</br></br>
		<div class="commandspec">
			Decaf is a strongly typed C-like language. The feature set is trimmed down considerably from what is usually part of a full-fledged programming language. This is done to keep the programming assignments manageable. Despite these limitations, Decaf will be able to handle interesting and non-trivial programs.</br></br>
			Here is an example Decaf program:
			<pre class="brush: cpp;">
			extern func print_int(int) void;

			package GreatestCommonDivisor {
				var a int = 10;
				var b int = 20;

				func main() int {
					var x, y, z int;
					x = a;
					y = b;
					z = gcd(x, y);

					// print_int is part of the standard input-output library
					print_int(z);
				}

				// function that computes the greatest common divisor
				func gcd(a int, b int) int {
					if (b == 0) { return(a); }
					else { return( gcd(b, a % b) ); }
				}
			}</pre>
		</div></br>
		The challenge of this course stemmed from learning the theoretical aspects of <a href="https://en.wikipedia.org/wiki/Lexical_analysis"><b>Lexical Analysis</b></a>, <a href="https://en.wikipedia.org/wiki/Parsing"><b>Grammar Parsing</b></a>, and <a href="https://en.wikipedia.org/wiki/Code_generation_(compiler)"><b>Code Generation</b></a>, then applying them to working code to design a complex system based off a set of specifications.
		The three main tools we used were:
		<ol>
			<li><a href="http://flex.sourceforge.net/" target="_parent"><b>Flex</b></a></li>
			<li><a href="https://www.gnu.org/software/bison/manual/" target="_parent"><b>YACC/Bison</b></li>
			<li><a href="http://llvm.org/" target="_parent"><b>LLVM</b></a></li>
		</ol>
		<div class="section">
			<h1 id="proj_repo"><a href="#table-of-contents">Project Repository</a></h1>
			All of the files for this project can be found <a href="https://github.com/CorreyL/compiler/tree/master/assign4/answer"><b>here</b></a>.
			<h2 id="lex"><a href="#table-of-contents">Flex: Lexical Analyzer</a></h2>
			<h1 id="lex_regexp"><a href="#table-of-contents">Regular Expressions</a></h1>
			The main part of the Lexical Analyzer is composed of <a href="https://en.wikipedia.org/wiki/Regular_expression"><b>Regular Expressions</b></a>, a sequence of characters that define a search pattern, used in pattern matching with strings or string matching.</br></br>
			
			Simple examples of Regular Expressions are as follows:</br></br>
			<code>gr(a|e)y</code> : The word grey or gray, spelled either way </br></br>
			<code>[a-zA-Z]</code> : Lower & Uppercase Alphabetic characters </br></br>
			<code>[^a-zA-Z]</code> : Any characters that are NOT Lower & Uppercase Alphabetic characters ([^ ] : Any characters but the ones that follow) </br></br>
			<code>[a-zA-Z0-9]</code> : Alphanumeric characters</br></br>
			<code>(a|b)*</code> : Any number of the letters a or b in any order, or the empty string "" (* : Kleene Closure matches the preceding element(s) zero or more times)</br></br>
			<code>(a|b)*c</code> : Starting with any number of the letters a or b in any order, or the empty string "", and ends with the letter c</br></br>
			The topic of regular expressions is a broad subject, and the above barely scratches the surface of what they're capable of.</br>
			<h1 id="lex_decaf"><a href="#table-of-contents">Lexical Analyzer for Decaf</a></h1>
			Flex builds upon the the programming language C. The basic structure of a Flex program is demonstrated below:
			<pre class="brush: cpp;">
			%{ // Indicates to Flex that C syntax is going to be enclosed inside the {}

			#include &lt;iostream>
			using namespace std;
			int mylineno = 0;

			%}

			%option noyywrap // A Flex option to toggle a specific setting

			// Defining Regular Expressions into variables for use below 
			alpha   [A-Za-z]
			dig     [0-9]

			%% // Indicates to Flex that the definition section of the program is ending, and the token definition section is beginning

			// Regular Expression         C Syntax to process the corresponding Regular Expression
			[{alpha}\_][{alpha}\_{dig}]*  { yylval.sval = new string(yytext); return T_ID; }
			{dig}{dig}*					  { yylval.number = conv_intconstant(yytext); return T_INTCONSTANT; }
			= 							  { return T_ASSIGN; }
			;							  { return T_SEMICOLON; }
			 
			%% // Indicates to Flex that the token definitions section is ending, and the main program is beginning

			int yyerror(const char *s) {
				cerr << lineno << ": " << s << " at char " << tokenpos << endl;
				return 1;
			}</pre>
			The main challenge of building a Lexical Analyzer was following the <a href="http://anoopsarkar.github.io/compilers-class/decafspec.html" target="_blank"><b>Decaf Specification</b></a> and building regular expressions for the following tokens:</br>
			<pre>
	T_AND            &&
	T_ASSIGN         =
	T_BOOLTYPE       bool
	T_BREAK          break
	T_CHARCONSTANT   char_lit (see section on Character literals)
	T_COMMA          ,
	T_COMMENT        comment
	T_CONTINUE       continue
	T_DIV            /
	T_DOT            .
	T_ELSE           else
	T_EQ             ==
	T_EXTERN         extern
	T_FALSE          false
	T_FOR            for
	T_FUNC           func
	T_GEQ            >=
	T_GT             >
	T_ID             identifier (see section on Identifiers)
	T_IF             if
	T_INTCONSTANT    int_lit (see section on Integer literals)
	T_INTTYPE        int
	T_LCB            {
	T_LEFTSHIFT      <<
	T_LEQ            <=
	T_LPAREN         (
	T_LSB            [
	T_LT             <
	T_MINUS          -
	T_MOD            %
	T_MULT           *
	T_NEQ            !=
	T_NOT            !
	T_NULL           null
	T_OR             ||
	T_PACKAGE        package
	T_PLUS           +
	T_RCB            }
	T_RETURN         return
	T_RIGHTSHIFT     >>
	T_RPAREN         )
	T_RSB            ]
	T_SEMICOLON      ;
	T_STRINGCONSTANT string_lit (see section on String literals)
	T_STRINGTYPE     string
	T_TRUE           true
	T_VAR            var
	T_VOID           void
	T_WHILE          while
	T_WHITESPACE     whitespace (see section on Whitespace)</pre>
	Building regular expressions for some of the above are easier than others. Below are a few samples, ranging from the easier ones to the harder ones.
	<ol>
		<li><b>Reserved Keywords</b></br>
			As one would expect, the regular expression for these tokens are the same as when typed in decaf, as such:
			<ul>
				<li>extern {return T_EXTERN;}</li>
				<li>return {return T_RETURN;}</li>
				<li>continue {return T_CONTINUE;}</li>
			</ul>
		</li></br>
		<li>
			<b>Variable Identifier</b></br>
			As in C, variable names can be any sequence of letters, numbers and the character '_' as long as it starts with a letter. The regular expression for this is:
			<ul>
				<li>[a-zA-Z\_][a-zA-Z\_0-9]*   { yylval.sval = new string(yytext); return T_ID; }</li>
			</ul></br>
			<b>Note:</b> In the regular expression, '\' indicates an escaped character in Flex, as '_' would otherwise be read as a Flex command.</br>yylval.sval defines a type that will be used in the Grammar Parser, and yytext is where the inputted variable name is stored. This allows the Grammar Parser to retrieve the variable name from the token T_ID when needed.
		</li></br>
		<li>
			<b>Escaped Characters In Character Literals</b></br>
			As in C, character literals are any characters enclosed in single quotes, ', and treated as an integer corresponding to their ASCII integer values. The regular expression for this is:</br>
			<pre class="brush: cpp;">
			[']([^\\n']|[\\][nrtvfab\\\'\"])['] { 
				char escape_check = yytext[1]; 
				char newvar = yytext[2]; 
				if(escape_check == '\\'){
					yylval.number = char_lit_esc_char(newvar);
				}
				else{
					yylval.number = yytext[1];
				} 
				return T_CHARCONSTANT;
			}</pre>
			In simpler terms, the regular expression above defines characters literals as:
			<code>`'` { char | escaped_char } `'`</code></br></br>
			Handling regular character literals is as easy as using the C function <a href="http://en.cppreference.com/w/cpp/string/byte/atoi" target="_blank"><b>atoi()</b></a>, which converts a single character to the corresponding ASCII integer value.</br></br>
			In order to handle escaped characters however, we opted to check whether or not it was an escaped character by looking for the '\' character in the first position. Given that was the case, then we used the char_lit_esc_char() function, which is defined as follows:
			<pre class="brush: cpp;">
			int char_lit_esc_char(char newvar){
				if(newvar == 'r'){
					return 13;
				}
				else if(newvar == 't'){
					return 9;
				}
				else if(newvar == 'f'){
					return 12;
				}
				else if(newvar == 'v'){
					return 11;
				}
				else if(newvar == 'n'){
					return 10;
				}
				else if(newvar == '\''){
					return 39;
				}
				else if(newvar == 'b'){
					return 8;
				}
				else if(newvar == 'a'){
					return 7;
				}
				else if(newvar == '\\'){
					return 92;
				}
				else if(newvar == '"'){
					return 34;
				}
				else{
					return atoi(yytext);
				}
			}</pre>
			Which determines what character is being escaped, and returning the corresponding ASCII integer value of the character.
		</li></br>
		<li>
			<b>Escaped Characters In String Literals</b></br>
			String literals are any sequence of characters inside of double quotes, "".This proved to be the most challenging regular expression to handle. Given that one wanted to express symbols such as ", \, or escaped characters such as new line (\n), tab (\t), etc. in a string, the lexical analyzer needs to recognise these situations and process them accordingly. As such, the regular expression for this is:</br></br>
			<ul>
				<li>\"([^\\"\n]|\\[nrtvfab\\'"])*\"	{ yylval.sval = esc_char(yytext); return T_STRINGCONSTANT; }</li>
			</ul></br>
			In simpler terms, the regular expression above defines string literals as:
			<code>`"` { char | escaped_char } `"`</code></br></br>
			The function esc_char() is defined as:</br>
			<pre class="brush: cpp;">
				string *esc_char(string os){
					string* s = new string(os);
					s->erase(0, 1);
					s->pop_back();
					int i = s->find("\\n");
					if(i != string::npos){
						const char* replace = "\n";
						s->replace(s->find("\\n"), 2, replace);
					}
					i = s->find("\\t");
					if(i != string::npos){
						const char* replace = "\t";
						s->replace(s->find("\\t"), 2, replace);
					}
					i = s->find("\\v");
					if(i != string::npos){
						const char* replace = "\v";
						s->replace(s->find("\\v"), 2, replace);
					}
					i = s->find("\\r");
					if(i != string::npos){
						const char* replace = "\r";
						s->replace(s->find("\\r"), 2, replace);
					}
					i = s->find("\\a");
					if(i != string::npos){
						const char* replace = "\a";
						s->replace(s->find("\\a"), 2, replace);
					}
					i = s->find("\\f");
					if(i != string::npos){
						const char* replace = "\f";
						s->replace(s->find("\\f"), 2, replace);
					}
					i = s->find("\\b");
					if(i != string::npos){
						const char* replace = "\b";
						s->replace(s->find("\\b"), 2, replace);
					}
					i = s->rfind("\\\"");
					if(i != string::npos){
						const char* replace = "\"";
						s->replace(s->find("\\\""), 2, replace);
					}
					i = s->find("\\\\");
					if(i != string::npos){
						const char* replace = "\\";
						s->replace(s->find("\\\\"), 2, replace);
					}
					return s;
				}</pre>
				The function esc_char() was defined to ensure that the correct sequence of characters was stored in the token. For example, without processing the initial string in esc_char(), the token would store the string "\\\"" as that sequence of characters, as opposed to storing the intended string of "\"".
		</li>
	</ol>
	<h1 id="lex_example01"><a href="#table-of-contents">Example of Lexical Analyzer for Decaf</a></h1>
	The following are a couple of sample decaf programs, and what the Lexical Analyzer passes to the Grammar Parser:
	<pre class="brush: cpp;">
	// assign.decaf
	package C {
	func f() void {
			var x int;
			x = 1;
		}
	}</pre>
	The lexical analyzer would return:
	<pre>
	T_PACKAGE package
	T_ID C
	T_LCB {
	T_FUNC func
	T_ID f
	T_LPAREN (
	T_RPAREN )
	T_VOID void
	T_LCB {
	T_VAR var
	T_ID x
	T_INT int
	T_SEMICOLON ;
	T_ID x
	T_ASSIGN =
	T_INTCONSTANT 1
	T_SEMICOLON ;
	T_RCB }
	T_RCB }</pre>
	<pre class="brush: cpp;">
	// stringconst1.decaf
	extern func print_string(string) void;

	package Test {
		func main() int {
			print_string("hello, world\n");
		}
	}</pre>
	The lexical analyzer would return:
	<pre>	T_EXTERN extern
	T_FUNC func
	T_ID print_string
	T_LPAREN (
	T_STRINGTYPE string
	T_RPAREN )
	T_VOID void
	T_SEMICOLON ;
	T_PACKAGE package
	T_ID Test
	T_LCB {
	T_FUNC func
	T_ID main
	T_LPAREN (
	T_RPAREN )
	T_INTTYPE int
	T_LCB {
	T_ID print_string
	T_LPAREN (
	T_STRINGCONSTANT "hello, world"
	T_RPAREN )
	T_SEMICOLON ;
	T_RCB }
	T_RCB }</pre>
	<h1 id="lex_source"><a href="#table-of-contents">Source Code</a></h1>
	The source code for the Lexical Analyzer for Decaf can be found <a href="https://github.com/CorreyL/compiler/blob/master/assign4/answer/decafcomp.lex" target="_parent"><b>here</b></a>.
		</div>
		<div class="section">
			<h2 id="parser">YACC/Bison Grammar Parser</h2>
			<h1 id="parser_ast"><a href="#table-of-contents">Abstract Syntax Tree</a></h1>
			An <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_parent"><b>Abstract Syntax Tree</b></a> (hereafter AST) is the resulting parse tree that is generated from a <a href="https://en.wikipedia.org/wiki/Context-free_grammar"><b>context free grammar</b></a> (hereafter CFG).</br></br>
			A common and simple example of an AST that can be generated from a CFG is given the CFG:</br>
			<pre>
		Rule 1: E -> E + T | T
		Rule 2: T -> T * F | F
		Rule 3: F -> [0-9]</pre>
			Which is a CFG that is expresses a single digit, or a sequence of products and sums, where a sum will be the right most expression.</br></br>
			An example of how an AST would be derived from this CFG is:
			<pre>
		Express: 1 * 2 + 3
		
		E -> E + T (Rule 1)
		E + T -> T + T (Rule 1)
		T + T -> T * F + T (Rule 2)
		T * F + T -> F * F + T (Rule 2)
		F * F + T -> 1 * F + T (Rule 3)
		1 * F + T -> 1 * 2 + T (Rule 3)
		1 * 2 + T -> 1 * 2 + F (Rule 2)
		1 * 2 + F -> 1 * 2 + 3 (Rule 3)</pre>
		The resulting tree from this grammar would be:</br>
		<img src="ast_example.png"/>
		<h1 id="parser_grammar"><a href="#table-of-contents">Grammar Parser for Decaf</a></h1>
		YACC/Bison builds on the programming language C++. The basic structure of a YACC/Bison program is as follows:</br>
		(Note that this builds upon the example .lex file as shown in <a href="#lex_decaf"><b>Lexical Analyzer for Decaf</b></a>)
		<pre class="brush: cpp;">
		%{ // Initial variable definitions, including the beginning C++ include/using statements
		#include &lt;iostream>
		#include &lt;ostream>
		#include &lt;string>
		#include &lt;cstdlib>

		int yylex(void);
		int yyerror(char *); 

		#include "default.cc"

		using namespace std;

		%} // Links the tokens defined in the .lex file (the Lexical Analyzer)

		%union{
			class decafAST *ast;
			std::string *sval;
		}

		%token &lt;sval> T_ID
		%token T_INTCONSTANT
		%token T_ASSIGN
		%token T_SEMICOLON

		%% // CFG definitions begin

		start: assign // Indicates to Flex how the start of a program using this grammar should be

		assign: T_ID T_ASSIGN T_INTCONSTANT T_SEMICOLON // The definition of the expression 'assign', which is composed of the indicated tokens
				{ 
					$$ = new AssignVarAST(*$1, $3); // Calling the function that creates the AST for an assign expression
				}

		%% // Main YACC/Bison Program begins

		int main() {
			// parse the input and create the abstract syntax tree
			int retval = yyparse();
			return(retval >= 1 ? EXIT_FAILURE : EXIT_SUCCESS);
		}</pre>
		The Grammar Parser for Decaf builds ASTs by using <a href="http://www.cplusplus.com/doc/tutorial/polymorphism/" target="_parent"><b>C++ Polymorphism</b></a>, where decafAST is the base class:
		<pre class="brush: cpp;">
		/// decafAST - Base class for all abstract syntax tree nodes.
		class decafAST {
		public:
			virtual ~decafAST() {}
			virtual string str() { return string(""); }
			virtual llvm::Value *Codegen() = 0;
		};</pre>
		And to build on the initial example, the AssignVarAST() function is defined as:
		<pre class="brush: cpp;">
		class AssignVarAST : public decafAST { // Note the use of Polymorphism
			string VarName;
			decafAST *Expression;
			public:
			AssignVarAST(string varname, decafAST *expression) : VarName(varname), Expression(expression) {}
			~AssignVarAST() {
				if (Expression != NULL) { delete Expression; }
			}
			string str() { return string("AssignVar") + "(" + VarName + "," + getString(Expression) + ")"; }
		};</pre>
		Note that if the function str() inside AssignVarAST is called, then it will print out it's specific AST. For example, if it were given the arguments:
		<pre class="brush: cpp;">
		AssignVarAST(x, 10);</pre>
		Then the returned string would be:</br></br>
		<code>AssignVar(x,1)</code></br></br>
		As such, every expression needs its own defined AST class, which can be found in <a href="https://github.com/CorreyL/compiler/blob/master/assign4/answer/decafcomp.cc"><b>decafcomp.cc</b></a></br></br>
		Notable challenges when implementing the Grammar Parser was handling multiple ways to define the same action. For example, as is valid in C++, Decaf supports typecasting multiple variables in one line, in addition to other variable declarations on separate lines, like so:
		<pre class="brush: cpp;">
		var a bool;
		var b int;
		var x, y, z int // The equivalent of int x,y,z in C/C++</pre>
		Handling the multiple lines of variable definitions require utilizing the class decafStmtList, which is a list of Decaf ASTs:
		<pre class="brush: cpp;">
		class decafStmtList : public decafAST {
			list&lt;decafAST *> stmts;
			public:
				decafStmtList() {}
				~decafStmtList() {
					for (list&lt;decafAST *>::iterator i = stmts.begin(); i != stmts.end(); i++) {
						delete *i;
					}
				}
				int size() { return stmts.size(); }
				void push_front(decafAST *e) { stmts.push_front(e); }
				void push_back(decafAST *e) { stmts.push_back(e); }
				string str() { return commaList&lt;class decafAST *>(stmts); }
		};
		
		// ...
		
		field_decl_list: field_decl_list field_decl // Notice how this expression is left recursive
			{ decafStmtList *slist = (decafStmtList *)$1; slist->push_back($2); $$ = slist; }
		| /* empty */
			{ decafStmtList *slist = new decafStmtList(); $$ = slist; }
		;</pre>
		Then to handle multiple variable definitions on the same line, we needed to create a new class, IdList:
		<pre class="brush: cpp;">
		class IdList : public decafAST {
			list&lt;class decafAST *> Vars;
			string Type;
			int Size;

			public:
				IdList(){}
				IdList(string name, string type, int size){
					Type = type;
					Size = size;
					FieldDeclAST *temp = new FieldDeclAST(name, Type, Size);
					Vars.push_front(temp);
				}
				~IdList(){}

				void push_front(string name, string type, int size){
					FieldDeclAST *temp = new FieldDeclAST(name, type, size);
					Vars.push_front(temp);
				}
				void push_back(string name, string type, int size){
					FieldDeclAST *temp = new FieldDeclAST(name, type, size);
					Vars.push_back(temp);
				}
				void addVar(string name) {
					FieldDeclAST *temp = new FieldDeclAST(name, Type, Size);
					Vars.push_front(temp);
				}
				virtual llvm::Value* Codegen();
				string str(){ return commaList&lt;class decafAST *>(Vars);}
		};
		
		// ... 
		
		field_decl: T_VAR id_list T_SEMICOLON { $$ = $2; } // Notice how the actual variable names are not defined in this expression, but a separate expression, id_list, instead

		id_list: T_ID decaf_type { // The parser reads from right to left, so we instantiate the list here, and push on to it every variable declared on the same line
				$$ = new IdList(*$1, *$2, -1); 
			}
			| T_ID T_COMMA id_list { 
					IdList *temp = (IdList*)$3;
					temp->addVar(*$1); $$ = temp;
			}</pre>
		<h1 id="parser_example01"><a href="#table-of-contents">Example of Grammar Parser for Decaf</a></h1>
		To build upon the previous examples in <a href="#lex_example01"><b>'Example of Lexical Analyzer for Decaf'</b></a>:
		<pre class="brush: cpp;">
		// assign.decaf
		package C {
		func f() void {
				var x int;
				x = 1;
			}
		}</pre>
		The grammar parser would return:
		<pre>
	Program(None,Package(
			C,None,Method(
				f,VoidType,None,MethodBlock(
					None,AssignVar(
						x,NumberExpr(1)
					)
				)
			)
		)
	)</pre>
		<pre class="brush: cpp;">
		// stringconst1.decaf
		extern func print_string(string) void;

		package Test {
			func main() int {
				print_string("hello, world\n");
			}
		}</pre>
		The grammar parser would return:
		<pre>
	Program(ExternFunction(
		print_string,VoidType,VarDef("hello, world!\n",StringType)
	),Package(Test,None,None))</pre>
		<h1 id="parser_source"><a href="#table-of-contents">Source Code</a></h1>
		The source code for the Grammar Parser for Decaf can be found <a href="https://github.com/CorreyL/compiler/blob/master/assign4/answer/decafcomp.y" target="_parent"><b>here</b></a>.
		</div>
		<div class="section">
			<h2 id="codegen">LLVM Code Generation</h2>
			<h1 id="codegen_ir"><a href="#table-of-contents">Intermediate Representation</a></h1>
			We used LLVM to generate an <a href="https://en.wikipedia.org/wiki/Intermediate_representation" target="_parent"><b>Intermediate Representation</b></a>, which in terms of complexity falls in between high-level languages (such as C/C++) and low-level languages (such as assembly). A sample LLVM program is as follows:
			<pre class="brush: plain;">
			define void @f() {
			entry:
				%x = alloca i32 ; Allocating memory for the variable x for a 32-bit integer
				store i32 1, i32* %x ; Storing the value 1 into the variable x
				ret void
			}</pre>
			Using the LLVM Library proved to be the most challenging part of the course, <a href="http://llvm.org/docs/doxygen/html/classes.html" target="_parent"><b>as the LLVM API is quite large</b></a>.
			<h1 id="codegen_symboltable"><a href="#table-of-contents">Symbol Tables</a></h1>
			Before going into Code Generation, the data structure of <a href="https://en.wikipedia.org/wiki/Symbol_table" target="_parent"><b>Symbol Tables</b></a> should be briefly noted.</br></br>
			As with many other programming languages, <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)" target="_parent"><b>Scope</b></a> is taken into account in Decaf as well. Whenever we enter a new scope (ie. Whenever a left curly brace { is used), a new Symbol Table is pushed on to the stack of Symbol Tables.</br></br>
			
			Inside of a particular Scope, any variable definitions are stored inside of the most recent Symbol Table pushed on to the stack. If we leave the Scope (ie. Whenever a right curly brace } is used), the most recent Symbol Table is popped off the stack, and any variable definitions within the popped off Symbol Table is lost.</br></br>
			
			It is important to note that the Decaf Compiler also supports <a href="https://en.wikipedia.org/wiki/Variable_shadowing" target="_parent"><b>Variable Shadowing</b></a>; if the most recent Symbol Table does not contain a variable that has been called, we traverse the rest of the stack to see if we can find the variable having been defined before the current scope.</br></br>
			
			The Source Code for our implementation of a Symbol Table is as follows:
			<pre class="brush: cpp;">
			typedef struct{
				int lineno;
				string type;
				string* reg_dest; // Register Destination
				llvm::AllocaInst* mem_loca = NULL; // Memory Address Location
				llvm::GlobalVariable* globvar_mem_loca = NULL;
				llvm::ArrayType* array_type = NULL;
				bool spilled; // Spilled "indicates if the value is to be found in a register or in memory"
				llvm::Value* Val = NULL;
			} descriptor;
			
			// ... 
			
			class symboltable{
			public:
				symboltable() {
				}

				void new_symtbl() {
					symbol_table *new_symtbl = new symbol_table();
					symtbl.push_front(new_symtbl);
				}

				void pop_symtbl() {
					if (symtbl.empty())
						throw runtime_error("no symbol table to remove here!");
					symtbl.pop_front();
				}

				void remove_symtbl() {
					symbol_table *tbl;
					if (symtbl.empty())
						throw runtime_error("no symbol table to remove here!");
					else
						tbl = symtbl.front();
				tbl->clear();
				delete(tbl);
					symtbl.pop_front();
				}

				void enter_symtbl(string ident, descriptor *d) {
					symbol_table *tbl;
					symbol_table::iterator find_ident;

					if (symtbl.empty())
						throw runtime_error("no symbol table created yet!");

					tbl = symtbl.front();
					if ((find_ident = tbl->find(ident)) != tbl->end()) {
						if(SymTblErr){ cerr << "Warning: redefining previously defined identifier: " << ident << endl; }
						delete(find_ident->second);
						tbl->erase(ident);
					}
					(*tbl)[ident] = d;
				}

				descriptor* access_symtbl(string ident) {
					for (symbol_table_list::iterator i = symtbl.begin(); i != symtbl.end(); ++i) {
						symbol_table::iterator find_ident;
						if ((find_ident = (*i)->find(ident)) != (*i)->end()) return find_ident->second;
					}
					return NULL;
				}

			private:
				typedef map&lt;string, descriptor* > symbol_table;
				typedef list&lt;symbol_table* > symbol_table_list;
				symbol_table_list symtbl;
			};</pre>
			<h1 id="codegen_codegen"><a href="#table-of-contents">Code Generation for Decaf</a></h1>
			Within the base class decafAST(), we added a virtual function 'Codegen()':
			<pre class="brush: cpp;">
			class decafAST {
			public:
				virtual ~decafAST() {}
				virtual string str() { return string(""); }
				virtual llvm::Value *Codegen() = 0;
			};</pre>
			The Compiler traverses the generated AST, and when an AST object has its Codegen() function called, the LLVM library is utilized to generate the associated code.</br></br>
			To build on the example of assign.decaf, I've modified the code slightly:
			<pre class="brush: cpp;">
			// assign.decaf
			extern func print_int(int) void; // Importing the function print_int() from the Decaf Standard Library
			package C {
				func f() void { // Defining the function f()
					var x int;
					x = 1;
					print_int(x);
				}
				func main() int{ // Defining the main() function
					f(); // Calling f(), defined above
				}
			}</pre>
			Note how I've added a call to define the externally defined print_int() from the Decaf Standard Library, added print_int() inside of the f() definition, defined a main() function and call f() inside of it.</br></br>
			The expected output from this program after it has been compiled and run should be:</br></br>
			<code>1</code></br></br>
			To walk through the code, we begin with PackageAST():
			<pre class="brush: cpp;">
			decafpackage: T_PACKAGE T_ID T_LCB field_decl_list method_decl_list T_RCB
			{ $$ = new PackageAST(*$2, (IdList *)$4, (decafStmtList *)$5);
				symtable->new_symtbl(); // For FieldDeclList (Global Sym Table)
				tablenumber++;
				$4->Codegen();
				$5->Codegen();
				if(SavingMain != NULL){SavingMain->Codegen();}
				symtable->remove_symtbl();
				tablenumber--;
				delete $2;
			}</pre>
			The most important aspect of the above code is line 6, wherein $5 (method_decl_list) has its Codegen() function called. Method_decl_list is a list of method_decl, which is defined as:
			<pre class="brush: cpp;">
			method_decl: T_FUNC T_ID T_LPAREN method_var_list T_RPAREN method_type method_block {
				if(*$2 == "main"){
					SavingMain = new MethodDeclAST(*$2, *$6, (MethodVarListAST *)$4, (MethodBlockAST *)$7);
					$$ = SavingMain;
				}
				else{
					$$ = new MethodDeclAST(*$2, *$6, (MethodVarListAST *)$4, (MethodBlockAST *)$7);
				}
				delete $2;
			}
			;</pre>
			In this case, two MethodDeclAST objects are created, one for f() and one for main().</br></br>
			For both, the same Codegen() function is called:
			<pre class="brush: cpp;">
			Value* MethodDeclAST::Codegen() {
				symtable->new_symtbl(); // Creates a new symbol table since we're entering a new block of code
				if (Name == "main"){ // The function being defined is main()
					gen_main_def();
				}
				else{ // The function being defined is not main, thus we need to retrieve its arguments, if any
					list&lt;Value*> ArgTypes;
					vector&lt;string> ArgNames;
					MethodVarsList->FillOutArgs(ArgTypes, ArgNames); // Needed for functionArgs push_back Type* (either bool or int)

					FunctionProtos[Name] = gen_function_def(ArgTypes, Name, methodType, ArgNames, MBlock); // NeededForFunctionArgs & FunctionArgsName is passed by reference, so we don't need to empty it
				}
				// ...
			}</pre>
			gen_function_def() is what generates the LLVM code for f(), which is defined as follows:
			<pre class="brush: cpp;">
			llvm::Function *gen_function_def(list<Value*> &FunctionArgs, string FunctionName, string FunctionType, vector<string> &FunctionArgsName, MethodBlockAST* mblock){
			llvm::FunctionType *FT;
				vector<Type*> FunctionArgTypes;
				int i = 0;
				list<Value*> AllocaFuncArgs;
				while( !FunctionArgs.empty() ){
					//Changing all function args to back temp
					FunctionArgTypes.push_back(FunctionArgs.front()->getType());
					AllocaFuncArgs.push_back(FunctionArgs.front());
					FunctionArgs.pop_front();
				}
				FT = get_function_type(FunctionType, FunctionArgTypes);
				/*FUNCTION DECLARATION*/
				llvm::Function *TheFunction = llvm::Function::Create(FT, llvm::Function::ExternalLinkage, FunctionName, TheModule);
				if (TheFunction->getName() != FunctionName){
					TheFunction->eraseFromParent();
					TheFunction = TheModule->getFunction(FunctionName);
					if (!TheFunction->empty()){
						throw runtime_error("ERROR: redefinition of function");
						//return 0;
					}
				}
				if (TheFunction == 0) {
					throw runtime_error("empty function block");
				}
				setFuncArgs(TheFunction, FunctionArgsName);
				// Create a new basic block which contains a sequence of LLVM instructions
				llvm::BasicBlock *BB = llvm::BasicBlock::Create(llvm::getGlobalContext(), "entry", TheFunction);
				// All subsequent calls to IRBuilder will place instructions in this location
				Builder.SetInsertPoint(BB);
				while( !AllocaFuncArgs.empty() ){
					AllocaInst* Alloca;
					llvm::Type* tempType = AllocaFuncArgs.front()->getType();
					Alloca = defineVariable(tempType, FunctionArgsName[i]);
					AllocaFuncArgs.pop_front();
					i++;
				}
				llvm::BasicBlock *CurBB = Builder.GetInsertBlock();
				//Gives you a link to the current basic block
				llvm::Function *func = Builder.GetInsertBlock()->getParent();

				verifyFunction(*TheFunction);
				return TheFunction;
			}</pre>
			While complicated due to the nature of the LLVM C++ API, calling gen_function_def() generates the function definition in LLVM, resulting in:
			<pre class="brush: plain;">
			define void @f() {
				entry:
				; Note that the insertion point is here, so when the block of code inside the function declaration for f() 
				; has its Codegen() function run, all of it will go in here.
			}</pre>
			The remainder of MethodDeclAST generates the LLVM Code for the body of f():
			<pre class="brush: cpp;">
			Value* MethodDeclAST::Codegen() {
				// ...
				Value* ReturnTy = MBlock->Codegen(); // Performing the codegen for the block of code within the function declaration
				if(methodType == "VoidType"){
					Builder.CreateRet(NULL);
				}
				symtable->remove_symtbl(); // Exiting a block of code, need to remove the symbol table
				Builder.ClearInsertionPoint(); // Tells LLVM to stop writing code in for this block
			}</pre>
			Note how a call to Codegen() is done inside a Codegen() definition. This recursive nature of calling Codegen() is how we're able to traverse the AST with only a single call at decafpackage. This recursive Codegen() call generates the body of the function in LLVM. To see how it specifically does that, we need to look at MBlock->Codegen, which is of the type BlockAST::Codegen():</br></br>
			<pre class="brush: cpp;">
			Value* BlockAST::Codegen() {
				symtable->new_symtbl();
				tablenumber++;
				BlockVarDefs->Codegen();
				BlockStatementList->Codegen();
				symtable->remove_symtbl();
				tablenumber--;
			}</pre>
			Once again, note the recursive Codegen() calls. It is important to note that Decaf requires all variable declarations to be done before any statements can be called, unlike many programming languages where variable and statements can be done interchangably. BlockVarDefs->Codegen() calls the MethodVarListAST::Codegen() definition:</br>
			<pre class="brush: cpp;">
			Value* MethodVarListAST::Codegen() {
				AllocaInst *Alloca;
				while(MethodVars.size() != 0){
					VarDefAST* vd = getFront();
					if(retrieve_front_type()=="IntType"){
						Alloca = Builder.CreateAlloca(Type::getInt32Ty(getGlobalContext()), nullptr, retrieve_front());
						Builder.CreateStore(Builder.getInt32(0), Alloca); // Zero initialize
					}
					else if(retrieve_front_type()=="BoolType"){
						Alloca = Builder.CreateAlloca(Type::getInt1Ty(getGlobalContext()), nullptr, retrieve_front());
						Builder.CreateStore(Builder.getInt1(0), Alloca); // Zero initialize
					}
					else{
						throw runtime_error("This type is not recognised.");
					}
					descriptor* temp = new descriptor; // Adding the variable to the symbol table
					temp->lineno = lineno;
					temp->mem_loca = Alloca;
					symtable->enter_symtbl(retrieve_front(), temp);
					MethodVars.pop_front();
				}
			}</pre>
			The resulting LLVM code is now:
			<pre class="brush: plain;">
			define void @f() {
			entry:
				%x = alloca i32
				store i32 0, i32* %x ; All variables in Decaf are zero initialized
			}</pre>
			Next, BlockStatementList->Codegen() is done. Since there are two statements,
			<pre class="brush: cpp;">
			x = 1;
			print_int(x);</pre>
			These two Codegen() functions will be called:
			<pre class="brush: cpp;">
			Value* AssignVarAST::Codegen() {
				descriptor* temp = NULL;
				llvm::Value *V = Expression->Codegen();
				setValue(V);
				temp = symtable->access_symtbl(VarName);
				if(temp == NULL){throw runtime_error("AssignVarAST::This variable has not been declared.");}
				llvm::AllocaInst* Alloca = temp->mem_loca;
				Builder.CreateStore(Val, Alloca);
			}
			
			// ...
			
			Value* MethodCallAST::Codegen() {
				Function *CallFunc = TheModule->getFunction(MethodName);
				if (CallFunc == 0){
					throw runtime_error("could not find the function requested.");
				}

				vector<Value*> FuncArgs;
				if(Expression != NULL){ // An empty DecafStmtList is registered as NULL
					if(Expression->size() != 0){
						FuncArgs = Expression->VectorOfArgs(); //return AllArts(stmts), vector of Values
						// Vector of args, takes list and push_back
					}
				}

				// Check if the function has a return type void
				Value *V;
				if (Expression != NULL){
					V = Expression->Codegen();
				}
				if(MethodName == "print_int" && V->getType()->isIntegerTy(1)){

					V = Builder.CreateZExt(V, Builder.getInt32Ty(), "zexttmp");
					return Builder.CreateCall(CallFunc, V, "calltmp");
				}
				bool isVoid = CallFunc->getReturnType()->isVoidTy();
				return Builder.CreateCall(FunctionProtos[MethodName], FuncArgs, isVoid ? "" : "calltmp");
			}</pre>
			Note that MethodCallAST::Codegen() has recursive Codegen() calls as well, which simply retrieves the variable being called in its argument, in this case x:
			<pre class="brush: cpp">
			Value* VariableExprAST::Codegen() {
			descriptor* access = symtable->access_symtbl(Value);
			if( access != NULL ){
				llvm::Value *V;
				if(access->mem_loca != NULL){
					V = access->mem_loca;
				}
				else{
					V = access->globvar_mem_loca;
				}
				return Builder.CreateLoad(V,Value);
			}
			else{
				throw runtime_error("VariableExprAST: This variable has not been defined inside the Symbol Table");</pre>
			This retrieves the value of x from the Symbol Table. The LLVM definition of f() is now fully generated:</br>
			<pre class="brush: plain">
			define void @f() {
			entry:
				%x = alloca i32
				store i32 0, i32* %x
				store i32 1, i32* %x
				%x1 = load i32, i32* %x
				%calltmp = call i32 @print_int(i32 %x1)
				ret void
			}</pre>
			For main(), recall that gen_main_def() was called in MethodDeclAST::Codegen(), which is defined as:
			<pre class="brush: cpp;">
			llvm::Function *gen_main_def() {
				// Create the top-level definition for main
				llvm::FunctionType *FT = llvm::FunctionType::get(llvm::IntegerType::get(llvm::getGlobalContext(), 32), false);
				llvm::Function *TheFunction = llvm::Function::Create(FT, llvm::Function::ExternalLinkage, "main", TheModule);
				if (TheFunction == 0) {
					throw runtime_error("empty function block");
				}
				// Create a new basic block which contains a sequence of LLVM instructions
				llvm::BasicBlock *BB = llvm::BasicBlock::Create(llvm::getGlobalContext(), "entry", TheFunction);
				// All subsequent calls to IRBuilder will place instructions in this location
				Builder.SetInsertPoint(BB);
				Builder.CreateRet(ConstantInt::get(getGlobalContext(), APInt(32, 1)));
				Builder.SetInsertPoint(BB, TheFunction->getEntryBlock().begin());
				CurrentFunction = TheFunction;
				return TheFunction;
			}</pre>
			Similar to gen_function_def(), but less complicated since main() is only ever generated with it. Currently, the LLVM code looks like
			<pre class="brush: plain">
			define i32 @main() {
			entry:
				; Note that the insertion point is here, so when the block of code inside main() 
				; has its Codegen() function run, all of it will go in here. 
				ret i32 1
			}</pre>
			Note that a return does not have to be explicitly made in the .decaf code, but is a requirement in LLVM, thus it defaults to <code> return 1</code>.</br></br>
			Main only has a single statement inside of it, a method call to f(), thus MethodCallAST::Codegen() is called again, which reuslts in:
			<pre class="brush: plain">
			define i32 @main() {
			entry:
				call void @f()
				ret i32 1
			}</pre>
			All together, the resulting code generated from the Decaf Compiler is:
			<pre class="brush: plain">
			; ModuleID = 'module for very simple expressions'

			declare i32 @print_int(i32)

			define void @f() {
			entry:
				%x = alloca i32
				store i32 0, i32* %x
				store i32 1, i32* %x
				%x1 = load i32, i32* %x
				%x2 = load i32, i32* %x
				%calltmp = call i32 @print_int(i32 %x1)
				ret void
			}

			define i32 @main() {
			entry:
				call void @f()
				ret i32 1
			}</pre>
			As expected, we get the desired result when we run the LLVM Code:
			<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt379/assign1/assign4/answer$ ./decafcomp < test.decaf 2> test.ll
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt379/assign1/assign4/answer$ ./run-llvm-code.sh test.ll
	1</pre>
			<h1 id="codegen_source">Source Code</h1>
			The source code for the Code Generation can be found <a href="https://github.com/CorreyL/compiler/blob/master/assign4/answer/decafcomp.y#L536" target="_parent"><b>here</b></a>.
		</div>
		<div class="section">
		<h2 id="compiler_example00">Examples of Decaf Compiler</h2>
		<h1 id="compiler_example01"><a href="#table-of-contents">Greatest Common Divisor (Recursive Function)</a></h1>
		From the Preface, demonstrating the capability of recursive function calling:
		<pre class="brush: cpp;">
		extern func print_int(int) void;

		package GreatestCommonDivisor {
			var a int = 10;
			var b int = 20;

			func main() int {
				var x, y, z int;
				x = a;
				y = b;
				z = gcd(x, y);

				// print_int is part of the standard input-output library
				print_int(z);
			}

			// function that computes the greatest common divisor
			func gcd(a int, b int) int {
				if (b == 0) { return(a); }
				else { return( gcd(b, a % b) ); }
			}
		}</pre>
		Generates the LLVM Code:
		<pre class="brush: plain;">
		; ModuleID = 'module for very simple expressions'

		@a = internal global i32 10
		@b = internal global i32 20

		declare i32 @print_int(i32)

		define i32 @gcd(i32 %a, i32 %b) {
		entry:
			%a1 = alloca i32
			store i32 %a, i32* %a1
			%b2 = alloca i32
			store i32 %b, i32* %b2
			%b3 = load i32, i32* %b2
			%eqtemp = icmp eq i32 %b3, 0
			%if-cond = icmp ne i1 %eqtemp, false
			br i1 %if-cond, label %then5, label %else

		then5:                                            ; preds = %entry
			%a4 = load i32, i32* %a1
			ret i32 %a4

		else:                                             ; preds = %entry
			%b6 = load i32, i32* %b2
			%a7 = load i32, i32* %a1
			%b8 = load i32, i32* %b2
			%sremtemp = srem i32 %a7, %b8
			%b9 = load i32, i32* %b2
			%a10 = load i32, i32* %a1
			%b11 = load i32, i32* %b2
			%sremtemp12 = srem i32 %a10, %b11
			%calltmp = call i32 @gcd(i32 %b6, i32 %sremtemp)
			ret i32 %calltmp
		}

		define i32 @main() {
		entry:
			%x = alloca i32
			store i32 0, i32* %x
			%y = alloca i32
			store i32 0, i32* %y
			%z = alloca i32
			store i32 0, i32* %z
			%a = load i32, i32* @a
			store i32 %a, i32* %x
			%b = load i32, i32* @b
			store i32 %b, i32* %y
			%x1 = load i32, i32* %x
			%y2 = load i32, i32* %y
			%x3 = load i32, i32* %x
			%y4 = load i32, i32* %y
			%calltmp = call i32 @gcd(i32 %x1, i32 %y2)
			store i32 %calltmp, i32* %z
			%z5 = load i32, i32* %z
			%z6 = load i32, i32* %z
			%calltmp7 = call i32 @print_int(i32 %z5)
			ret i32 1
		}</pre>
		(Note the use of <a href="https://en.wikipedia.org/wiki/Control_flow_graph" target="_parent"><b>Control Flow</b></a> for the if/else statement.)</br></br>
		When run, we get:
		<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt379/assign1/assign4/answer$ ./decafcomp < ../testcases/dev/gcd.decaf 2> test.ll
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt379/assign1/assign4/answer$ ./run-llvm-code.sh test.ll
	10</pre>
		<h1 id="compiler_example02"><a href="#table-of-contents">Chaining Function Calls</a></h1>
		A chain of function calls can also be done:
		<pre class="brush: cpp;">
		extern func print_int(int) void;

		package Test {
				func test3(a int) void {
						print_int(a);
				}
				func test2(a int) void {
						print_int(a);
						test3(a + 1);
				}
				func test1(a int) void {
						print_int(a);
						test2(a + 1);
				}
				func main() int {
						test1(1);
				}
		}</pre>
		Which generates the LLVM Code:
		<pre class="brush: plain;">
		declare i32 @print_int(i32)

		define void @test3(i32 %a) {
		entry:
			%a1 = alloca i32
			store i32 %a, i32* %a1
			%a2 = load i32, i32* %a1
			%a3 = load i32, i32* %a1
			%calltmp = call i32 @print_int(i32 %a2)
			ret void
		}

		define void @test2(i32 %a) {
		entry:
			%a1 = alloca i32
			store i32 %a, i32* %a1
			%a2 = load i32, i32* %a1
			%a3 = load i32, i32* %a1
			%calltmp = call i32 @print_int(i32 %a2)
			%a4 = load i32, i32* %a1
			%addtmp = add i32 %a4, 1
			%a5 = load i32, i32* %a1
			%addtmp6 = add i32 %a5, 1
			call void @test3(i32 %addtmp)
			ret void
		}

		define void @test1(i32 %a) {
		entry:
			%a1 = alloca i32
			store i32 %a, i32* %a1
			%a2 = load i32, i32* %a1
			%a3 = load i32, i32* %a1
			%calltmp = call i32 @print_int(i32 %a2)
			%a4 = load i32, i32* %a1
			%addtmp = add i32 %a4, 1
			%a5 = load i32, i32* %a1
			%addtmp6 = add i32 %a5, 1
			call void @test2(i32 %addtmp)
			ret void
		}

		define i32 @main() {
		entry:
			call void @test1(i32 1)
			ret i32 1
		}</pre>
		When run, we get the following result:
		<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt379/assign1/assign4/answer$ ./decafcomp < ../testcases/dev/intcallchain3expr.decaf 2> test.ll
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt379/assign1/assign4/answer$ ./run-llvm-code.sh test.ll
	123</pre>
		<h1 id="compiler_example03"><a href="#table-of-contents">Boolean Short Circuiting</a></h1>
		<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation" target="_parent"><b>Boolean Short Circuiting</b></a> is also supported in the Decaf Compiler:
		<pre class="brush: cpp;">
		extern func print_int(int) void;
		extern func print_string(string) void;

		package foo {
				func foo() bool {
						print_string("foo");
						return(false);
				}
				func main() int {
						var flag bool;
						flag = true || foo() && !true;
						print_int(flag);
				}
		}</pre>
		Note that the function foo() should not be called given that short circuiting is supported, thus print_string("foo") should not occur.</br></br>
		The following LLVM Code is generated:
		<pre class="brush: plain;">
		; ModuleID = 'module for very simple expressions'

		@globalstring = private unnamed_addr constant [4 x i8] c"foo\00"
		@globalstring.1 = private unnamed_addr constant [4 x i8] c"foo\00"

		declare i32 @print_int(i32)

		declare void @print_string(i8*)

		define i1 @foo() {
		entry:
			call void @print_string(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @globalstring, i32 0, i32 0))
			ret i1 false
		}

		define i32 @main() {
		entry:
			%flag = alloca i1
			store i1 false, i1* %flag
			br i1 true, label %orend, label %orfalse
			ret i32 1

		orfalse:                                          ; preds = %entry
			%calltmp = call i1 @foo()
			br i1 %calltmp, label %andtrue, label %andend

		orend:                                            ; preds = %andend, %entry
			%phival1 = phi i1 [ true, %entry ], [ %phival, %andend ]
			store i1 %phival1, i1* %flag
			%flag2 = load i1, i1* %flag
			%flag3 = load i1, i1* %flag
			%zexttmp = zext i1 %flag3 to i32
			%calltmp4 = call i32 @print_int(i32 %zexttmp)

		andtrue:                                          ; preds = %orfalse
			br label %andend

		andend:                                           ; preds = %andtrue, %orfalse
			%phival = phi i1 [ %calltmp, %orfalse ], [ false, %andtrue ]
			br label %orend
		}</pre>
		Which gives us the following result:</br>
		<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt379/assign1/assign4/answer$ ./decafcomp < ../testcases/dev/skct.decaf 2> test.ll
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt379/assign1/assign4/answer$ ./run-llvm-code.sh test.ll
	1</pre>
	Note how the string "foo" is not printed, thanks to short-circuit evaluation.
	</div>
</html>