<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<!-- To display C++ Code -->
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<script type="text/javascript" src="../syntax_highlighter/scripts/shCore.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushCpp.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushBash.js"></script>
		<script type="text/javascript" src="../syntax_highlighter/scripts/shBrushPlain.js"></script>
		<link type="text/css" rel="stylesheet" href="../syntax_highlighter/styles/shCoreDefault.css"/>
		<script type="text/javascript">SyntaxHighlighter.all();</script>

		<link rel="stylesheet" type="text/css" href="../style.css"/>
		<style type="text/css">
		.arg1{color:red;}
		.arg2{color:green;}
		.arg3{color:blue;}
		.arg4{color:orange;}
		table{max-width: 500px;}
		</style>
		<title>Digital Portfolio of Correy Lim</title>
	</head>
	<body>
	<h3>CMPT 276: Introduction to Software Engineering (January 2016 - April 2016)</h3>
	<div class="document">
		<div id="table-of-contents">
			<h2>Table of Contents</h2>
			<body>
			<div class="tableofcontents">
				<table>
					<li><a href="#preface">Preface</a></li>
					<li><a href="#database-layer">Low-Level Interface: Database Layer</a></li>
						<ul>
							<li><a href="#database-introduction">Introduction</a></li>
							<li><a href="#database-example1">Example of A Call to the Server</a></li>
							<li><a href="#database-commands">List of All Commands</a></li>
							<li><a href="#database-command1">Command: Get All Entities From A Specific Partition</a></li>
							<li><a href="#database-command2">Command: Get All Entities Containing All Specified Properties</a></li>
							<li><a href="#database-command3">Command: Add the Specified Property (Name/Value Pair) To All Entities</a></li>
							<li><a href="#database-command4">Command: Update the Specified Property In All Entities</a></li>
							<li><a href="#database-example2">Example Use of BasicServer</a></li>
								<ul>
									<li><a href="#database-specific-example1">Get All Entities From A Specific Partition</a></li>
									<li><a href="#database-specific-example2">Get All Entities Containing All Specified Properties</a></li>
								</ul>
							<li><a href="#database-conclusion">Conclusion</a></li>
							<li><a href="#database-source">Source Code</a></li>
						</ul>
					<li><a href="#authentication-layer">Authentication: Secure Record Access</a></li>
						<ul>
						<li><a href="#auth-introduction">Introduction</a></li>
						<li><a href="#auth-server">Authentication Server</a></li>
						<li><a href="#auth-command1">Command: Get A Read Token</a></li>
						<li><a href="#auth-command2">Command: Get An Update Token</a></li>
						<li><a href="#auth-example1">Example Use of AuthServer</a></li>
						<li><a href="#auth-conclusion">Conclusion</a></li>
						</ul>
					<li><a href="#session-layer">High-Level Interface: Session Layer</a></li>
						<ul>
						<li><a href="#user-introduction">Introduction</a></li>
						<li><a href="#user-commands">List of All Commands</a></li>
						<li><a href="#user-command1">Command: Sign On</a></li>
						</ul>
				</table>
			</div>
			</body>
		</div>
		<div class="section" id="preface">
		<h2>Preface</h2>
		<p>
			In this course I was tasked with building a back-end for a hypothetical web-based or mobile application (such as a social network), specifically to store user-inputted data such as usernames, passwords, status updates, etc.
		</p>
		<p>
			The main components of the project are:
			<ul>
				<b>
				<li><a href="https://azure.microsoft.com/en-us/" target="_parent">Microsoft Azure</a></li>
				<li><a href="http://www.stroustrup.com/C++11FAQ.html" target="_parent">C++11</a></li>
				<li><a href="https://microsoft.github.io/cpprestsdk/annotated.html" target="_parent">Casablanca REST: C++ API for Microsoft Azure</a></li>
				</b>
			</ul>
		</p>
		<p>
			We specifically used the <a href="https://azure.microsoft.com/en-us/documentation/articles/storage-table-design-guide/" target="_parent">Azure Table service</a>, which stored <i>entities</i> (equivalent to rows in a spreadsheet) that are uniquely identified by their Partition and Row column entries. Every entity has an associated JSON Object that stores properties. Each property within the JSON object is a pair, the first of which is generally a std::string to describe the property and the second a web::json::value that holds the property. To use artists as an example:
		</p>
		<center><table style="width:70%" border="1">
			<tr>
				<th>Partition</th>
				<th>Row</th> 
				<th>JSON Object</th>
			</tr>
			<tr>
				<td>Musician</td>
				<td><a href="https://en.wikipedia.org/wiki/Tegan_and_Sara" target="_parent">Tegan Quin</a></td> 
				<td>Genre: Indie Pop</br>
				Band: Tegan & Sara
				</td>
			</tr>
			<tr>
				<td>Musician</td>
				<td><a href="https://en.wikipedia.org/wiki/Banks_(singer)" target="_parent">Banks</a></td> 
				<td>Genre: Alternative R&B</br>
				Latest Song: Gemini Feed
				</td>
			</tr>
			<tr>
				<td>Musician</td>
				<td><a href="https://en.wikipedia.org/wiki/Shura_(musician)" target="_parent">Shura</a></td> 
				<td>Genre: Electropop</br>
				Latest Album: Nothing's Real</td>
			</tr>
			<tr>
				<td>Actor</td>
				<td><a href="https://en.wikipedia.org/wiki/Rami_Malek" target="_parent">Rami Malek</a></td> 
				<td>TV Show: <a href="https://en.wikipedia.org/wiki/Mr._Robot_(TV_series)" target="_parent">Mr. Robot</a></br>
				</td>
			</tr>
			<tr>
				<td>Actor</td>
				<td><a href="https://en.wikipedia.org/wiki/Krysten_Ritter" target="_parent">Krysten Ritter</a></td> 
				<td>TV Show: <a href="https://en.wikipedia.org/wiki/Jessica_Jones_(TV_series)" target="_parent">Jessica Jones</a></td>
			</tr>
		</table></br></center>
		<p>
			Here we have a table of artists, where the Partition specifies the role of the individual, the Row specifies the name of the individual, and the JSON object for each entity have various property pairs.</br></br>
			The back-end was set up as a tiered service as 4 different servers:</br>
			<center><img src="cmpt276architecture.jpg"/></br></center>
		</p>
		</div>	
		<div class="section" id="database-layer">
			<p>
				<h2>1. Low-Level Interface: Database Layer (BasicServer.cpp)</h2>
				<h1 id="database-introduction">Introduction</h1>
				The Database Layer is an interface to the Storage Layer, specifically <a href="https://azure.microsoft.com/en-us/" target="_parent"><b>Microsoft Azure</b></a>. This ensures that if the application needs to be moved to another Cloud Storage Service, such as <a href="https://aws.amazon.com/?nc2=h_lg" target="_parent"><b>Amazon AWS</b></a> or <a href="https://cloud.google.com/" target="_parent"><b>Google Cloud Datastore</b></a>, the only code that needs to be changed would be in this lowest-level service, without having to change any other part of the appllication.</br></br>
				
				Calls to the Database Layer have two parts: An HTTP Request Method and a URI. The service supports 4 basic HTTP request methods: </br>
				<ul>
					<li>GET</li>
					<li>POST</li>
					<li>PUT</li>
					<li>DELETE</li>
				</ul>
				The URI specifies the server being called, the command, and any corresponding arguments required by the command. 
			</p>
			<h1 id="database-example1">Example of A Call to the Server</h1>
			The simplest command to demonstrate a call to the server is 'CreateTableAdmin', the specifications of which are as follows:</br></br>
			<div class ="commandspec" style="margin-left: 1em;"> <!-- Change the class so that it doesn't go across the width of the page. -->
				<b>Create A Table</b>
				<ul>
				<li>HTTP method: POST</li>
				<li>Operation: CreateTableAdmin</li>
				<li>Parameters: Table Name</li>
				<li>Response codes:</li>
					<ul>
						<li>status_codes::BadRequest (400): Missing table name</li>
						<li>status_codes::Created (201): Table created</li>
						<li>status_codes::Accepted (202): Table already existed</li>
					</ul>
				</ul>
				This operation is idempotent—“creating” a table that has already been created returns an HTTP 202 Accepted status.</br>
			</div></br>
			Which is performed by the URI:</br></br>
			<code>http://<b class=arg1>localhost</b>:<b class=arg2>34568</b>/<b class=arg3>CreateTableAdmin</b>/<b class=arg4>MyTable</b></code></br></br>
			The server is hosted on the <b class=arg1>local machine</b>, the <b class=arg2>port number 34568</b> is specific to this server, the command is <b class=arg3>CreateTableAdmin</b> and the arugment passed in is <b class=arg4>MyTable</b>.</br></br>
			The Unix command <a href="https://curl.haxx.se/docs/manpage.html" target="_parent"><b>cURL</b></a> is used to make calls to the server. Put together with the HTTP Request, the cURL command to create a table is:</br></br>
			<code>$ curl -i -X post http://localhost:34568/CreateTableAdmin/MyTable</code></br></br>
			The following is the C++ code found in BasicServer.cpp that handles this call.
			<!-- C++ Code for CreateTableAdmin -->
			<pre class="brush: cpp;">
			/*
				Top-level routine for processing all HTTP POST requests.
			*/
			void handle_post(http_request message) {
				string path {uri::decode(message.relative_uri().path())};
				cout << endl << "**** POST " << path << endl;
				auto paths = uri::split_path(path);
				// Need at least an operation and a table name
				if (paths.size() < 2) {
					message.reply(status_codes::BadRequest);
					return;
				}

				string table_name {paths[1]};
				cloud_table table {table_cache.lookup_table(table_name)};

				// Create table (idempotent if table exists)
				if (paths[0] == create_table) {
					cout << "Create " << table_name << endl;
					bool created {table.create_if_not_exists()};
					cout << "Administrative table URI " << table.uri().primary_uri().to_string() << endl;
					if (created)
						message.reply(status_codes::Created); // Table is created (RC: 201)
					else
						message.reply(status_codes::Accepted); // Table already exists; unchanged (RC: 202)
				}
				else {
					message.reply(status_codes::BadRequest); // No table name given (RC: 400)
				}
			}</pre>
			The list of all commands in BasicServer can be found <a href="database-layer-commands.html" target="_blank" id="database-commands"><b>here</b></a>.</br></br>
			From the list above, we were tasked with implementing two commands in the Database Layer:
			<h1 id="database-command1">Get All Entities From A Specific Partition</h1>
			<div class="commandspec" style="margin-left: 1em;">
				<b>Get All Entities From A Specific Partition</b>
				<ul>
				<li>HTTP method: GET</li>
				<li>Operation: ReadEntityAdmin</li>
				<li>Parameters: Table Name, Partition Name, Row Name specified as '*'</li>
				<li>Response codes:</li>
					<ul>
						<li>status_codes::BadRequest (400): Missing table name, missing partition name, or missing * for row</li>
						<li>status_codes::NotFound (404): Table does not exist</li>
						<li>status_codes::OK (200): Table found and entities in the selected partition are returned in a JSON array. If there are no entries in the specified partition, return an empty JSON array.</li>
					</ul>
				</ul>
			</div>
			<p>
			The heart of this command is the if-block on line 10, wherein if the given partition matches an entity's partition in the table, the entity's Row and associated JSON Object is made into a pair and pushed on to the JSON array.</br></br>
			
			When all of the entities have been iterated through, the JSON array consisting of all the entity's with the passed in partition is passed back.
			</p>
			<pre class="brush: cpp;">
			if( paths[3] == "*" ){
				// Initialize all required variables
				table_query query {};
				table_query_iterator end;
				table_query_iterator it = table.execute_query(query); // Since the variable 'query' is empty, this sets the table_query_iterator, it, to the beginning
				vector&lt;value&gt; key_vec; // The JSON array to be passed back when the iterator has gone through all entities
				prop_vals_t keys; // Note that prop_vals_t is the class vector&lt;pair&lt;string,value&gt;&gt;;
				
				while(it != end){ // This while loop iterates through the table until it finds the requested partition
					if( paths[2] == it->partition_key() ){ // If the specified partition matches a partition in the table
						cout << "GET: " << it->partition_key() << " / " << it->row_key() << endl; 
						keys = { make_pair("Partition",value::string(it->partition_key())), make_pair("Row",value::string(it->row_key())) };
						keys = get_properties(it->properties(), keys);
						key_vec.push_back(value::object(keys)); // A partition is found, so push it on to the vector of JSON values
					}
					++it;
				}
				if( keys.empty() ){ // The requested partition is not a part of the table
					message.reply(status_codes::NotFound);
					return;
				}
				message.reply(status_codes::OK, value::array(key_vec));
				return;
			}</pre>
			<h1 id="database-command2">Get All Entities Containing All Specified Properties</h1>
			<div class="commandspec" id="database-command2" style="margin-left: 1em;">
			<b>Get All Entities Containing All Specified Properties</b>
			<ul>
				<li>HTTP method: GET</li>
				<li>Operation: ReadEntityAdmin</li>
				<li>Parameters: Table Name</li>
				<li>Body: Body: JSON object whose names denote properties and whose values are all the string "*". For example, the message body {"born": "*", "art": "*"} would get all entities who have both the properties born and art, with any values. The entity could have other properties as well-so long as an entity's properties include the specified properties, that entity would be returned as the result.</li>
				<li>Response codes:</li>
				<ul>
					<li>status_codes::BadRequest (400): Missing table name (if there is no JSON body, then a request with only a tablename is simply get all entities)</li>
					<li>status_codes::NotFound (404): Table does not exist</li>
					<li>status_codes::OK (200): Table found and entities with the selected properties are returned in a JSON array. If there are no entries with the specified properties, return an empty JSON array.</li>
				</ul>
			</ul>
			</div>
			<p>
			This command requires a passed in JSON object in order for the program to know what properties to look for. We store this in the variable 'stored_message' as an unordered_map&lt;string,string&gt;.</br>
			</p>
			<pre class="brush: cpp;">
			unordered_map&lt;string,string&gt; stored_message = get_json_body(message); // Retrieves the JSON Body from the cURL command </pre>
			<p>
			For each entity the iterator is at, the function begins by retrieving all the properties of the current entity, and iterating through all the property names, incrementing the variable 'equal' given that the current property matched one of the properties in the passed in JSON Body.</br>
			<pre class="brush: cpp;">
			const table_entity::properties_type& properties = it->properties(); // Obtain all properties of the current entity
			for (auto prop_it = properties.begin(); prop_it != properties.end(); ++prop_it) // Cycles through the properties of the current entity
			{
				unordered_map&lt;string,string&gt;::const_iterator got = stored_message.find(prop_it->first);
				if( got != stored_message.end() ){ // A property from the JSON body was found in the entity
					equal++;
				}
			}
			</pre>
			Once all of the properties of the current entity have been iterated through, we check the value of equal against the size of the JSON Body, which is determined by the number of properties stored within it. Given that they're equivalent, then the current entity contains all the passed in properties, thus it needs to be pushed on to the JSON Array and returned.
			<pre class="brush: cpp;">
			if( equal == stored_message.size() ){ // All properties from the JSON body were found in the entity
				cout << "Partition: " << it->partition_key() << " / Row: " << it->row_key() << endl;
				keys = { make_pair("Partition",value::string(it->partition_key())), make_pair("Row",value::string(it->row_key())) };
				keys = get_properties(it->properties(), keys);
				key_vec.push_back(value::object(keys));
			}
			</pre>
			This process is repeated until all the entities in the table have been iterated through, and all matching entities are passed back in the JSON Array. We get the resulting body of code.
			</p>
			<pre class="brush: cpp;">
			if(paths[0] == read_entity_admin){
				unordered_map&lt;string,string&gt; stored_message = get_json_body(message); // Retrieves the JSON Body from the cURL command
				if( stored_message.size() > 0 ){
					// Initialize all required variables
					table_query query {};
					table_query_iterator end;
					table_query_iterator it = table.execute_query(query); // Since the variable 'query' is empty, this sets the table_query_iterator, it, to the beginning
					table_entity entity; // The JSON array to be passed back when the iterator has gone through all entities
					prop_vals_t keys; // Note that prop_vals_t is the class vector&lt;pair&lt;string,value&gt;&gt;;
					vector&lt;value&gt; key_vec;
					int equal {0};

					while(it != end){
						equal = 0;
						const table_entity::properties_type& properties = it->properties(); // Obtain all properties of the current entity
						for (auto prop_it = properties.begin(); prop_it != properties.end(); ++prop_it) // Cycles through the properties of the current entity
						{
							unordered_map&lt;string,string&gt;::const_iterator got = stored_message.find(prop_it->first);
							if( got != stored_message.end() ){ // A property from the JSON body was found in the entity
								equal++;
							}
						}
						if( equal == stored_message.size() ){ // All properties from the JSON body were found in the entity
							cout << "Partition: " << it->partition_key() << " / Row: " << it->row_key() << endl;
							keys = { make_pair("Partition",value::string(it->partition_key())), make_pair("Row",value::string(it->row_key())) };
							keys = get_properties(it->properties(), keys);
							key_vec.push_back(value::object(keys));
						}
						++it;
					}
					message.reply( status_codes::OK, value::array(key_vec) );
					return;
				}
			}</pre>
			<h1 id="database-example2">Example Use of BasicServer</h1>
			Here is an example of entering the entities from the example table shown in the Preface
			<center><table style="width:70%" border="1">
				<tr>
					<th>Partition</th>
					<th>Row</th> 
					<th>JSON Object</th>
				</tr>
				<tr>
					<td>Musician</td>
					<td><a href="https://en.wikipedia.org/wiki/Tegan_and_Sara" target="_parent">Tegan Quin</a></td> 
					<td>Genre: Indie Pop</br>
					Band: Tegan & Sara
					</td>
				</tr>
				<tr>
					<td>Musician</td>
					<td><a href="https://en.wikipedia.org/wiki/Banks_(singer)" target="_parent">Banks</a></td> 
					<td>Genre: Alternative R&B</br>
					Latest Song: Gemini Feed
					</td>
				</tr>
				<tr>
					<td>Musician</td>
					<td><a href="https://en.wikipedia.org/wiki/Shura_(musician)" target="_parent">Shura</a></td> 
					<td>Genre: Electropop</br>
					Latest Album: Nothing's Real</td>
				</tr>
				<tr>
					<td>Actor</td>
					<td><a href="https://en.wikipedia.org/wiki/Rami_Malek" target="_parent">Rami Malek</a></td> 
					<td>TV Show: <a href="https://en.wikipedia.org/wiki/Mr._Robot_(TV_series)" target="_parent">Mr. Robot</a></br>
					</td>
				</tr>
				<tr>
					<td>Actor</td>
					<td><a href="https://en.wikipedia.org/wiki/Krysten_Ritter" target="_parent">Krysten Ritter</a></td> 
					<td>TV Show: <a href="https://en.wikipedia.org/wiki/Jessica_Jones_(TV_series)" target="_parent">Jessica Jones</a></td>
				</tr>
		</table></br></center>
		First, let's enter Partition: Musician, Row: Tegan Quin with the Properties: {Genre: Indie Pop, Band: Tegan & Sara}
		<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ curl -i -X post http://localhost:34568/CreateTableAdmin/Artists
	HTTP/1.1 201 Created
	Content-Length: 0

	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ curl -i -X put http://localhost:34568/UpdateEntityAdmin/Artists/Musicia
	n/Tegan_Quin/ -d '{"Genre":"Indie Pop","Band":"Tegan&Sara"}' -H "Content-Type: application/json"
	HTTP/1.1 200 OK
	Content-Length: 0

	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ curl -i -X get http://localhost:34568/ReadEntityAdmin/Artists
	HTTP/1.1 200 OK
	Content-Length: 85
	Content-Type: application/json

	[{"Band":"Tegan&Sara","Genre":"Indie Pop","Partition":"Musician","Row":"Tegan_Quin"}]
		</pre>
		Of course, typing in commands this long gets annoying quite quickly, so I opt to use Bash Scripting to ease this process of adding entities to a table:</br></br>
		First I set the variables by running
		<pre>	source setvars.sh</pre>
		Where setvars.sh is:
		<pre class="brush: bash;">
			B='http://localhost:34568'
			export B</pre>
		Then ran the following script addentity.sh:
		<pre class="brush: bash;">
			#!/bin/bash
			curl -i -X put $B/UpdateEntityAdmin/Artists/Musician/Banks/ -d '{"Genre":"Alternative_R&B","Latest_Song":"Gemini_Feed"}' -H "Content-Type: application/json";
			curl -i -X put $B/UpdateEntityAdmin/Artists/Musician/Banks/ -d '{"Genre":"Electropop","Latest_Album":"Nothings_Real"}' -H "Content-Type: application/json";
			curl -i -X put $B/UpdateEntityAdmin/Artists/Actor/Rami_Malek/ -d '{"TV_Show":"Mr. Robot"}' -H "Content-Type: application/json";
			curl -i -X put $B/UpdateEntityAdmin/Artists/Actor/Krysten_Ritter/ -d '{"TV_Show":"Jessica Jones"}' -H "Content-Type: application/json";</pre>
		And we get the following from the terminal:
		<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ ./addentity.sh
	HTTP/1.1 200 OK
	Content-Length: 0

	HTTP/1.1 200 OK
	Content-Length: 0

	HTTP/1.1 200 OK
	Content-Length: 0

	HTTP/1.1 200 OK
	Content-Length: 0

	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ ./dumptable.sh Artists
	HTTP/1.1 200 OK
	Content-Length: 338
	Content-Type: application/json

	[{"Partition":"Actor","Row":"Krysten_Ritter","TV_Show":"Jessica Jones"},
	{"Partition":"Actor","Row":"Rami_Malek","TV_Show":"Mr. Robot"},
	{"Genre":"Alternative_R&B,"Latest_Song":"Gemini_Feed","Partition":"Musician","Row":"Banks"},
	{"Genre":"Electropop","Latest_Album":"Nothings_Real","Partition":"Musician","Row":"Shura"},
	{"Band":"Tegan&Sara","Genre":"Indie Pop","Partition":"Musician","Row":"Tegan_Quin"}]</pre>
		<h1 id="database-specific-example1">An example of using 'Get All Entities From A Specific Partition':</h1>
		Here, I specify that I only want entities from the Partition 'Actor'
		<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/website/correyl.github.io$ curl -i -X get $B/ReadEntityAdmin/Artists/Actor/*
	HTTP/1.1 200 OK
	Content-Length: 135
	Content-Type: application/json

	[{"Partition":"Actor","Row":"Krysten_Ritter","TV_Show":"Jessica Jones"},
	{"Partition":"Actor","Row":"Rami_Malek","TV_Show":"Mr. Robot"}]</pre>
		<h1 id="database-specific-example2">An example of using 'Get All Entities Containing All Specified Properties':</h1>
		Here, I specify that I only want entities with the property "Genre".
		<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ curl -i -X get $B/ReadEntityAdmin/Artists -d '{"Genre":"*"}' -H "Content-Type: application/json"
	HTTP/1.1 200 OK
	Content-Length: 269
	Content-Type: application/json

	[{"Genre":"Alternative_R&B","Latest_Song":"Gemini_Feed","Partition":"Musician","Row":"Banks"},
	{"Genre":"Electropop","Latest_Album":"Nothings_Real","Partition":"Musician","Row":"Shura"},
	{"Band":"Tegan&Sara","Genre":"Indie Pop","Partition":"Musician","Row":"Tegan_Quin"}]</pre>
		Since the Musicians are the only ones with the property "Genre", they were the only entities returned.
		<h1 id="database-conclusion">Conclusion</h1>
		<p>
			While in hindsight these commands are quite simple to implement, it was the first time I worked with <a href="https://en.wikipedia.org/wiki/JSON" target="_parent"><b>JSON Objects</b></a> and a <a href="https://microsoft.github.io/cpprestsdk/annotated.html" target="_parent"><b>large C++ API</b></a>, and thus the main challenge was getting acclimated with utilizing these new tools by understanding the commands already implemented, then implementing new commands according to a set of specifications.
		</p>
		</div>
		<div class="section" id="authentication-layer">
			<h2>2. Authentication: Secure Record Access (AuthServer.cpp)</h2>
			<h1 id="auth-introduction">Introduction</h1>
			The basics of security for a cloud-based application were covered here, ensuring authenticated access to the service. Registered users required a username and associated password, and they were stored in a separate table in Microsoft Azure.</br></br>
			This authorization server provides the authorization service. Clients submit a name and password. If the name and password match the values stored in the special table AuthTable, the authentication server asks Azure to generate an access token for that user. This token will allow the user to read or update exactly one entity in one table. Tokens are only good for 24 hours after they are issued.
			<h1 id="auth-server">Authentication Server</h1>
			In order to keep track of the registered username & password combinations, we created a separate Microsoft Azure table named AuthTable, which has the following attributes:</br></br>
			<div class="commandspec" style="margin-left: 1em;">
				<b>AuthTable</b>
				<li>The table storing userid and password data. The table has only one partition, Userid, in which all entities are placed. The row key is the userid. For each user, the following three properties are stored:</li>
				<ol>
					<li><b>Password:</b> The password for this userid.</li>
					<li><b>DataPartition:</b> Combined with DataRow, the key for the single entity that this userid can access in DataTable.</li>
					<li><b>DataRow:</b> See DataPartition.</li>
				</ol>
				Note that the authentication server only reads AuthTable. The user data in the table is created and modified by an administrator using the standard calls to BasicServer.</br></br>
			</div>
			<p>For the purposes of the project, AuthTable only ensures authenticated access to a single table, named DataTable, which has the following attributes:</p>
			<div class="commandspec" style="margin-left: 1em;">
				<b>DataTable</b>
				<li>The table whose access is controlled by the authentication server. It has no specific structure beyond the standard Azure Table requirement that the key have two parts, a partition name and a row name.</li>
				<li>Note that the authentication server does not actually read or write DataTable. It only uses DataTable to create the security tokens. The actual reading and updating of DataTable is done by BasicServer using the authenticated read and write operations.</li>

				When a user is added to AuthTable, their entry will also have to be added to DataTable using curl.
			</div></br>
			There are only two commands that exist for the Authentication Server:
			<ol>
				<li><a href="#auth-command1"><b>Get A Read Token</b></a></li>
				<li><a href="#auth-command2"><b>Get An Update Token</b></a></li>
			</ol>
			<h1 id="auth-command1">Get A Read Token</h1>
			<div class="commandspec" style="margin-left: 1em;">
			<b>Get A Read Token</b>
			<ul>
				<li>HTTP method: GET</li>
				<li>Operation: GetReadToken</li>
				<li>Parameters: Userid</li>
				<li>Body: JSON object with the single property Password whose value is a password string. A password is an arbitrarily long sequence of printable 7-Bit ASCII characters</li>
				<li>Response codes: </li>
				<ul>
					<li>status_codes::BadRequest (400): The userid was missing from the URI, the message body did not have a property named 'Password', the message body included one or more properties other than Password, or the password was empty or included characters not in the printable 7-bit ASCII range</li>
					<li>status_codes::NotFound (404): The userid was not found in the table or it was found but the password stored in the table did not match the password provided by the client. Note: For security reasons, both these cases produce a NotFound result</li>
					<li>status_codes::OK (200): Token returned. The response body will be a JSON object containing the single property token, whose value is a string representing the token. Azure tokens are about 100 characters long</li>
				</ul>
			</ul>
			Note: For the purposes of this project, the passwords were sent over http. In a real system, calls to the authentication server would be done via https rather than http.
			</div></br>
			This command returns the first of two types of tokens that AuthServer returns. This token allows the user and entity associated with the token to read the data from the entity.</br></br>
			Inside of the while loop that iterates through all entities of DataTable, we first check for the Partition/Row combination "Userid"/(The passed in username):
			<pre class="brush: cpp;">
				if( it->partition_key() == "Userid" && it->row_key() == paths[1] )</pre>
			</pre>
			We iterate through all the properties of the current entity until we find the property "Password", and match the contents of it with the passed in Password.
			<pre class="brush: cpp;">
				for (auto prop_it = properties.begin(); prop_it != properties.end(); ++prop_it){ // Cycles through the properties of the current entity
					if(prop_it->first == "Password"){
						unordered_map&lt;string,string>::const_iterator got = json_body.find(prop_it->first); // Looking for the property Password in the JSON Body
						// ...
						string the_password = got->second;
					}
					if( the_password == prop_it->second.str() ){ // The password passed in from the JSON Body matched the password in this entity in AuthTable
						// ...
					}
				}
			</pre>
			Given that they match, we check that the passed in JSON Body also has the properties DataPartition and DataRow
			<pre class="brush: cpp;">
				for (auto prop_it2 = properties.begin(); prop_it2 != properties.end(); ++prop_it2){
					if(prop_it2->first == "DataPartition"){
						partition = prop_it2->second.str();
						cond1 = true;
					}
					if(prop_it2->first == "DataRow"){
						row = prop_it2->second.str();
						cond2 = true;
					}
				}
			</pre>
			Finally, we generate the token using the function do_get_token()  and pass the token back as a JSON Object.
			<pre class="brush: cpp;">
				if(cond1 == true && cond2 == true){ // The Partition and Row this Userid/Password combination allows for are found in the Properties of the entity in AuthTable
					pair&lt;status_code,string>; result = do_get_token (data_table, partition, row, table_shared_access_policy::permissions::read);
					// ...
					else if(result.first == status_codes::OK){
						prop_vals_t keys { make_pair("token",value::string(result.second)) };
						message.reply( status_codes::OK, value::object(keys) );
						return;
					}
				}
			</pre>
			The source code for this command is as follows:
			<pre class="brush: cpp;">
			if( paths[0] == get_read_token_op ){
				table_query query {};
				table_query_iterator end;
				table_query_iterator it = table.execute_query(query);
				if( json_body.size() &lt; 1 ){ // No JSON body passed in
					message.reply( status_codes::BadRequest );
					return;
				}
				if( json_body.size() > 1 ){ // Extra properties passed in
					message.reply( status_codes::BadRequest );
					return;
				}
				while(it != end){ // This while loop iterates through the table until it finds the requested partition
					if( it->partition_key() == "Userid" && it->row_key() == paths[1] ){ // Find Partition: Userid && Row: &lt;The Userid passed in>;
						const table_entity::properties_type& properties = it->properties();
						for (auto prop_it = properties.begin(); prop_it != properties.end(); ++prop_it) // Cycles through the properties of the current entity
						{
							if(prop_it->first == "Password"){
								//cout &lt;&lt; ", " &lt;&lt; prop_it->first &lt;&lt; ": " &lt;&lt; prop_it->second.str() &lt;&lt; endl;
								unordered_map&lt;string,string&rt;::const_iterator got = json_body.find(prop_it->first); // Looking for the property Password in the JSON Body
								if( got == json_body.end() ){ // The property "Password" was not found in the JSON body
									message.reply( status_codes::BadRequest );
									return;
								}
								bool cond1 {false};
								bool cond2 {false};
								string partition;
								string row;
								string the_password = got->second;
								if( the_password.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890~!@#$%^&*()_+=-") != std::string::npos ){ // Checking if the password is within the valid ASCII range
									message.reply( status_codes::BadRequest );
									return;
								}
								if( got->second == prop_it->second.str() ){ // The password passed in from the JSON Body matched the password in this entity in AuthTable
									for (auto prop_it2 = properties.begin(); prop_it2 != properties.end(); ++prop_it2){
										if(prop_it2->first == "DataPartition"){
											partition = prop_it2->second.str();
											cond1 = true;
										}
										if(prop_it2->first == "DataRow"){
											row = prop_it2->second.str();
											cond2 = true;
										}
									}
									if(cond1 == true && cond2 == true){ // The Partition and Row this Userid/Password combination allows for are found in the Properties of the entity in AuthTable
										pair&lt;status_code,string&rt; result = do_get_token (data_table, partition, row, table_shared_access_policy::permissions::read);
										if(result.first == status_codes::InternalError){
											message.reply( status_codes::InternalError );
											return;
										}
										else if(result.first == status_codes::OK){
											prop_vals_t keys { make_pair("token",value::string(result.second)) };
											message.reply( status_codes::OK, value::object(keys) );
											return;
										}
									}
									else{ // The DataPartition or DataRow passed in was not found in DataTable
										message.reply( status_codes::BadRequest );
										return;
									}
								}
								else{
									message.reply( status_codes::NotFound ); // The password does not match the Userid
									return;
								}
							}
						}
					}
					++it;
				}
				message.reply( status_codes::NotFound ); // Userid was not found
				return;
			}
			</pre>
			<h1 id="auth-command2">Get An Update Token</h1>
			<div class="commandspec" style="margin-left: 1em;">
				<b>Get An Update Token</b>
				<p>This operation has the same specification as <a href="#auth-command1"><b>"Get A Read Token"</b></a>, except for the following:</p>
				<ul>
					<li>Operation: GetUpdateToken</li>
					<li>Response codes:</li>
					<ul>
						<li>status_codes::OK (200): The returned token permits update operations as well as reads.</li>
					</ul>
				</ul>
			</div></br>
			This command returns the other type of tokens that AuthServer returns. This token allows the user and entity associated with the token to read and update the data from the entity.</br></br>
			The implementation is much the same as Get A Read Token, the only change is what type of token is retrieved, wherein the call to do_get_token has its third argument changed to </br></br><code>table_shared_access_policy::permissions::read | table_shared_access_policy::permissions::update</code></br></br>
			Which results in:
			<pre class="brush: cpp;">
				do_get_token (data_table, partition, row, table_shared_access_policy::permissions::read | table_shared_access_policy::permissions::update);</pre>
			This can be found on Line 46 below. The source code for this command is as follows:
			<pre class="brush: cpp;">
				if( paths[0] == get_update_token_op ){
					table_query query {};
					table_query_iterator end;
					table_query_iterator it = table.execute_query(query);
					if( json_body.size() < 1 ){ // No JSON body passed in
						message.reply( status_codes::BadRequest );
						return;
					}
					if( json_body.size() > 1 ){ // Extra properties passed in
						message.reply( status_codes::BadRequest );
						return;
					}
					while(it != end){ // This while loop iterates through the table until it finds the requested partition
						if( it->partition_key() == auth_table_userid_partition && it->row_key() == paths[1] ){ // Find Partition: Userid && Row: &lt;The Userid passed in>
							const table_entity::properties_type& properties = it->properties();
							for (auto prop_it = properties.begin(); prop_it != properties.end(); ++prop_it) // Cycles through the properties of the current entity
							{
								if(prop_it->first == "Password"){
									//cout << ", " << prop_it->first << ": " << prop_it->second.str() << endl;
									unordered_map&lt;string,string>::const_iterator got = json_body.find(prop_it->first); // Looking for the property Password in the JSON Body
									if( got == json_body.end() ){ // The property "Password" was not found in the JSON body
										message.reply( status_codes::BadRequest );
										return;
									}
									bool cond1 {false};
									bool cond2 {false};
									string partition;
									string row;
									string the_password = got->second;
									if( the_password.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890~!@#$%^&*()_+=-") != std::string::npos ){ // Checking if the password is within the valid ASCII range
										message.reply( status_codes::BadRequest );
										return;
									}
									if( got->second == prop_it->second.str() ){ // The password passed in from the JSON Body matched the password in this entity in AuthTable
										for (auto prop_it2 = properties.begin(); prop_it2 != properties.end(); ++prop_it2){
											if(prop_it2->first == "DataPartition"){
												partition = prop_it2->second.str();
												cond1 = true;
											}
											if(prop_it2->first == "DataRow"){
												row = prop_it2->second.str();
												cond2 = true;
											}
										}
										if(cond1 == true && cond2 == true){ // The Partition and Row this Userid/Password combination allows for are found in the Properties of the entity in AuthTable
											pair&lt;status_code,string> result = do_get_token (data_table, partition, row, table_shared_access_policy::permissions::read | table_shared_access_policy::permissions::update);
											if(result.first == status_codes::InternalError){
												message.reply( status_codes::InternalError );
												return;
											}
											else if(result.first == status_codes::OK){
												prop_vals_t keys { make_pair("token",value::string(result.second)) };
												message.reply( status_codes::OK, value::object(keys) );
												return;
											}
										}
										else{ // The DataPartition or DataRow passed in was not found in DataTable
											message.reply( status_codes::BadRequest );
											return;
										}
									}
									else{
										message.reply( status_codes::NotFound ); // The password does not match the Userid
										return;
									}
								}
							}
						}
						++it;
					}
				}</pre>
		<h1 id="auth-example1">Example Use of AuthServer</h1>
		We'll stick with the example of the entity Partition: Musician, Row: Tegan_Quin. First, we need to add this to entity to DataTable:
		<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ curl -i -X put http://localhost:34568/UpdateEntityAdmin/DataTable/Musician/Tegan_Quin/ -d '{"Genre":"Indie Pop","Band":"Tegan & Sara"}' -H "Content-Type: application/json"
	HTTP/1.1 200 OK
	Content-Length: 0

	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ ./dumptable.sh
	HTTP/1.1 200 OK
	Content-Length: 87
	Content-Type: application/json

	[{"Band":"Tegan & Sara","Genre":"Indie Pop","Partition":"Musician","Row":"Tegan_Quin"}]</pre>
		Next we need to add this entry to AuthTable. Recall that the entity in AuthTable needs to be:
		<ul>
			<li>Partition: Userid</li>
			<li>Row: Tegan_Quin (The Userid)</li>
			<li>Properties:</li>
			<ul>
				<li>Password:LY2D</li>
				<li>DataPartition:Musician</li>
				<li>DataRow:Tegan_Quin</li>
			</ul>
		</ul>
		The call to add this to AuthTable is as follows:
		<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ curl -i -X put http://localhost:34568/UpdateEntityAdmin/AuthTable/Userid/Tegan_Quin/ -d '{"Password":"LY2D","DataPartition":"Musician","DataRow":"Tegan_Quin"}' -H "Content-Type: application/json"
	HTTP/1.1 200 OK
	Content-Length: 0

	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ ./dumptable.sh AuthTable
	HTTP/1.1 200 OK
	Content-Length: 215
	Content-Type: application/json

	[{"DataPartition":"Musician","DataRow":"Tegan_Quin","Partition":"Userid","Password":"LY2D","Row":"Tegan_Quin"}]</pre>
	Finally, to generate the token, we make the call:
	<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ curl -i -X get http://localhost:34570/GetUpdateToken/Tegan_Quin/ -d '{"Password":"LY2D"}' -H "Content-Type: application/json"
	HTTP/1.1 200 OK
	Content-Length: 200
	Content-Type: application/json

	{"token":"sv=2015-04-05&sig=pKQ8yxUFaKv%2BSZFXU1R2ZJj64v%2BAEse4IXuTTWZnoDM%3D&spr=https%2Chttp&se=2016-08-21T20%3A22%3A33Z&sp=ru&tn=DataTable&spk=Musician&srk=Tegan_Quin&epk=Musician&erk=Tegan_Quin"}</pre>
	The above is an example of a token that is generated when a user logs on to alter the associated entity in DataTable.</br></br>
	
	To generate a Read Token, it would be done in the same way, except that the command sent to AuthTable when putting in Partition: Userid, Row:Tegan_Quin would be:
	<pre>
	vagrant@vagrant-ubuntu-trusty-32:~/cmpt276-projects/assign1$ curl -i -X get http://localhost:34570/<b class="arg1">GetReadToken</b>/Tegan_Quin/ -d '{"Password":"LY2D"}' -H "Content-Type: application/json"</pre>
	The difference is highlighted in red, where we call the command GetReadToken instead of GetUpdateToken.
		<h1 id="auth-conclusion">Conclusion</h1>
		</div>
		<div class="section" id="session-layer">
			<h2>3. High-Level Interface: Session Layer (UserServer.cpp & PushServer.cpp)</h2>
			<div id="user-introduction">
				This part of the project calls the services of BasicServer and AuthServer. There are two servers:
				<ul>
					<li>UserServer: A service for managing a user's social networking session</li>
					<li>PushServer: A service that pushes status updates to all a user's friends in the network</li>
				</ul>
				Note that calls are <b>never directly made to Azure Storage.</b></br></br>
				The main method of making calls from UserServer/PushServer to BasicServer or AuthServer lies in the following function 'do_request()' (which is defined inside of ClientUtils.cpp):
				<pre class="brush: cpp;">
				pair&lt;status_code,value&rt; do_request (const method& http_method, 
													   const string& uri_string, 
													   const value& req_body)</pre>
				A list of all the commands in UserServer can be found <a href="user-layer-commands.html" target="_blank" id="user-commands"><b>here</b></a>.
			</div>
			<h1 id="user-command1">Sign On</h1>
			As with any social network, a client is first required to sign on before they are able to use any of the services.</br></br>
			<div class="commandspec" style="margin-left: 1em;">
				<b>Sign On</b>
				<ul>
					<li>HTTP method: POST</li>
					<li>Operation: SignOn</li>
					<li>Parameters: Userid (Note: A Userid can only be alphabetic characters.)</li>
					<li>Body: JSON object with the single property Password whose value is a password string. The requirements for the password and the form of the JSON body are exactly as specified for <a href="">GetReadToken</a></li>
					<li>Response codes:</li>
					<ul>
						<li>status_codes::NotFound (404): Either the auth server responded NotFound or the auth server responded OK or no record exists in DataTable for this user.</br></br>

						The auth server makes no guarantees that there is an actual entity in DataTable associated with this user. Therefore, after succesfully receiving a token from the auth server (which guarantees that the userid and password are in AuthTable), the user server also attempts to read the entity in DataTable associated with this userid. If no such record exists, the user server returns status_codes::NotFound to a sign on request and does not record the user as signed in.</li></br>
						<li>status_codes::OK (200): The auth server returned a token and the expected record exists in DataTable. The user is recorded as signed in.</br></br>
						If the user is already signed in and attempts to sign in again with the same userid and password, the user server returns OK and continues their existing session.</br></br>
						If the user is already signed in and makes an unsuccessful attempt to sign in (for example, the second attempt includes the wrong password), the user server returns NotFound but continues their existing session.</li>
					</ul>
				</ul>
			</div></br>
			UserServer needs to keep track of the current active users at any time, thus we store active users in:
			<pre class="brush: cpp;">
				// To ensure multiple users can be logged on at once, the UserID will be the key, and the vector will hold the following information in this order:
				// vector&lt;string>[0] = (token)
				// vector&lt;string>[1] = (partition) (Country)
				// vector&lt;string>[2] = (row) (Full Name)
				unordered_map&lt; string, vector&lt;string> > active_users = {};</pre>
			For any given user sign on, UserServer begins by initializing all of the passed in information into variables:
			<pre class="brush: cpp;">
			unordered_map&lt;string,string> stored_message = get_json_body(message);
			// ...
			const string userID {paths[1]};
			string pwd {};
			unordered_map&lt;string,string>::const_iterator got = stored_message.find("Password");
			if( got != stored_message.end() ){
				pwd = got->second;
			}</pre>
			Then passing all of that information into the function to generate an Update Token from Azure, get_update_token():
			<pre class="brush: cpp;">
			/*
			Utility to get a token good for updating a specific entry
				from a specific table for one day.
			*/
			pair&lt;status_code,string> get_update_token(const string& addr,  const string& userid, const string& password) {
				value pwd {build_json_object (vector&lt;pair&lt;string,string>> {make_pair("Password", password)})};
				pair&lt;status_code,value> result {do_request (methods::GET,
																	 addr +
																	 get_update_token_op + "/" +
																	 userid,
																	 pwd
																	 )};
				cerr << "token " << result.second << endl;
				if (result.first != status_codes::OK)
					return make_pair (result.first, "");
				else {
					string token {result.second["token"].as_string()};
					return make_pair (result.first, token);
				}
			}
			// ...
			pair<status_code,string> auth_result {get_update_token(auth_addr, userID, pwd)};</pre>
			Given that the update token was generated successfully, we begin parsing out what Partition/Row entity this user has been given permission to update. An example of a token is:</br>
			<pre>
	sv=2015-04-05&sig=pKQ8yxUFaKv%2BSZFXU1R2ZJj64v%2BAEse4IXuTTWZnoDM%3D&spr=https%2Chttp&se=2016-08-21T20%3A22%3A33Z
	&sp=ru&tn=DataTable&<b class="arg1">spk=Musician</b>&<b class="arg2">srk=Tegan_Quin</b>&<b class="arg3">epk=Musician</b>&<b class="arg4">erk=Tegan_Quin</b></pre>
			As highlighted in the colours above, we can parse out the information we need from the token:</br>
			<pre class="brush: cpp;">
			if(auth_result.first == status_codes::OK){
				const string DataTable = "DataTable";
				// Begin parsing the partition and row from the token
				string row = auth_result.second.substr(auth_result.second.find("&erk=")+5, auth_result.second.length());
				string partition = auth_result.second.substr(auth_result.second.find("&epk=")+5, auth_result.second.find("&erk="));
				partition.erase(partition.length()-(row.length()+5), partition.length());
				
				// If there's a "," present in the DataRow, then Azure generates a token with "%2C" in place of ",". Need to change "%2C" with ",".
				if( row.find("%2C") != string::npos ){
					row.insert(row.find("%2C"),",");
					string html_comma = "%2C";
					row.erase(row.find("%2C"), html_comma.length());
				}
			}</pre>
			With this information we make a call to DataTable using get_entity_auth(), to ensure this DataPartition and DataRow combination exists as an entity in DataTable.</br>
			If the call succeeds, then we add this user to the list of active users and return status_codes::OK:
			<pre class="brush: cpp;">
				pair&lt;status_code,value> get_entity_auth (const string& addr, const string& table, const string& tok, const string& partition, const string&row){
					pair&lt;status_code,value> result {
					do_request(methods::GET, addr + read_entity_auth + "/" + table + "/" + tok + "/" + partition + "/" + row)};
					return result;
					}
				}
				// ...
				pair&lt;status_code,value> data_result {get_entity_auth(basic_addr, DataTable, auth_result.second, partition, row)};
				
				if(data_result.first == status_codes::OK){
					active_users.insert( { paths[1], {auth_result.second, partition, row} } ); // Adding the user to the unordered_map of active users
					message.reply(status_codes::OK);
					return;
				}
				else{ // No record exists in DataTable for this user
					message.reply(status_codes::NotFound);
					return;
				}</pre>
		</div>
		</br>
	</div>
</body>
</html>
<!--
<pre class="brush: cpp;">
</pre>
-->